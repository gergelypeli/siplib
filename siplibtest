#! /usr/bin/python3

import os
import logging
import logging.config
import sys
from weakref import proxy

from format import Addr, Uri, Nameaddr, Status, Hop
from party import PlannedEndpoint, PlannedRouting, Bridge, Routing
from sdp import Sdp
from registrar import RecordManager, Record
from subscript import SubscriptionManager, MessageSummaryEventSource, DialogEventSource
from util import setup_logging, my_exchandler, Oid
from mgw import MediaGateway
from mgc import Controller  #, PlayerMediaLeg  #, EchoMediaLeg
from switch import Switch
import zap
import resolver

TEST_DIALIN = 1
TEST_DIALOUT = 2
TEST = TEST_DIALIN

HOST = "otthon"
A_ADDR = Addr(HOST, 5060)
B_ADDR = Addr(HOST, 5062)

A_DOMAIN = "a.switch"
B_DOMAIN = "b.switch"

CALLER_NAMEADDR = Nameaddr(Uri(Addr(B_DOMAIN, None), "caller"), "Caller")

CALLEE_NAMEADDR = Nameaddr(Uri(Addr(B_DOMAIN, None), "callee"), "Callee")

A_AUTHNAME = "A_AUTHNAME"
A_HA1 = "A_HA1"
B_AUTHNAME = "B_AUTHNAME"
B_HA1 = "B_HA1"

SNOM_WEB = Addr("192.168.1.7", 80)
SNOM_ADDR = Addr("192.168.1.7", 2048)
SNOM_NUMBER = "phone"
SNOM_AUTHNAME = "phone"
SNOM_HA1 = "38450ead4036feb352c45462d8008511"  # md5(phone:a.switch:secret)

CALLEE_NUMBER = "555"

CALLER_SDP = Sdp.parse(b"""
v=0
o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5
s=SDP Seminar
i=A Seminar on the session description protocol
u=http://www.example.com/seminars/sdp.pdf
e=j.doe@example.com (Jane Doe)
c=IN IP4 224.2.17.12
t=2873397496 2873404696
a=recvonly
m=audio 49170 RTP/AVP 0
m=video 51372 RTP/AVP 99
a=rtpmap:99 h263-1998/90000
""")

MGW_HOST = "localhost"
MGW_ADDR = Addr(MGW_HOST, 20000)

MEDIA_HOST = "otthon"


class TestEndpoint(PlannedEndpoint):
    def identify(self, params):
        return None
        

    def wait_this_action(self, action_type):
        action = yield from self.wait_action()
        assert action and action["type"] == action_type
        return action
        

    def update_session(self, offer):
        if not offer.is_offer():
            raise Exception("Eiii...")
            
        answer = offer.flipped()
        
        for c in answer["channels"]:
            c["formats"] = [ f for f in c["formats"] if f["encoding"] in ("PCMA", "telephone-event") ]

        if not self.leg.media_legs:
            answer_channel = answer["channels"][0]
            ctype = answer_channel["type"]
            mgw_affinity = answer_channel.get("mgw_affinity")
            mgw_sid = self.ground.select_gateway_sid(ctype, mgw_affinity)

            answer_channel["mgw_affinity"] = mgw_sid
            media_leg = self.make_media_leg("player")
            media_leg.set_mgw(mgw_sid)
            self.leg.add_media_leg(media_leg)
        
        for c in answer["channels"]:
            c["send"], c["recv"] = c["recv"], c["send"]
            
        return answer
        
        
    def idle(self):
        self.leg.get_media_leg(0).play("playback.wav", ("PCMA", 8000, 1, None), volume=0.1, fade=3)

        while True:
            action = yield from self.wait_action()
            
            if action["type"] == "session":
                session = action["session"]
                if session.is_offer():
                    answer = self.update_session(session)
                    self.forward(dict(type="session", session=answer))
            elif action["type"] == "tone":
                self.logger.info("Okay, got a tone %s, fading out..." % action["name"])
                break
            else:
                self.logger.debug("Don't know what to do with %s, continuing..." % action["type"])
        
        if self.leg.media_legs:
            self.leg.media_legs[0].play(volume=0, fade=3)
            yield from self.sleep(3)
            
        self.forward(dict(type="hangup"))


class UnreachableEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Unreachable endpoint created.")
        
        yield from self.wait_this_action("dial")
        self.logger.debug("Got dial, but not answering anything.")

        yield from self.wait_this_action("hangup")
        self.logger.debug("And now the caller hung up.")


class RejectingEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Rejecting endpoint created.")
        
        yield from self.wait_this_action("dial")
        self.logger.debug("Got dial, but not now rejecting it.")

        self.forward(dict(type="reject", status=Status(603)))
        self.logger.debug("And now done.")


class RingingEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Ringing endpoint created.")
        
        yield from self.wait_this_action("dial")
        self.logger.debug("Got dial, now ringing forever.")

        self.forward(dict(type="ring"))

        yield from self.wait_this_action("hangup")
        self.logger.debug("And now the caller hung up.")


class CalleeEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Callee created.")
        
        action = yield from self.wait_this_action("dial")
        offer = action.get("session")
        self.logger.debug("Got offer:\n%s" % repr(offer))
        
        yield from self.sleep(1)
        answer = self.update_session(offer)
        self.forward(dict(type="ring", session=answer))
        
        # Force an UPDATE
        yield from self.sleep(1)
        offer = answer.flipped()
        self.forward(dict(type="session", session=offer))

        action = yield from self.wait_this_action("session")
        answer = action.get("session")
        self.logger.debug("Got answer:\n%s" % repr(answer))

        yield from self.sleep(1)
        self.forward(dict(type="accept"))

        yield from self.idle()
        
        self.logger.debug("Callee done.")


class CallerEndpoint(TestEndpoint):
    # TODO: call the phone without SDP!
    
    def plan(self):
        self.logger.debug("Caller created")
        
        address = yield from resolver.wait_resolve("index.hu")
        self.logger.debug("Resolved index.hu asynchronously to: %s" % address)
        
        yield from self.wait_input("Press any key to dial out!")
        
        src = {
            'type': "sip",  # FIXME: we lie here for mkctx
            'from': CALLER_NAMEADDR,
            'to': Nameaddr(Uri(Addr(A_DOMAIN, None), SNOM_NUMBER))
        }
        
        offer = None  # FIXME: make one from CALLER_SDP!
        action = dict(
            type="dial",
            call_info=self.get_call_info(),
            src=src,
            ctx={},
            session=offer
        )
        self.forward(action)

        while True:
            action = yield from self.wait_action()
        
            if action["type"] == "reject":
                self.logger.error("Oops, we got rejected!")
                return
            elif action["type"] == "accept":
                self.logger.info("Yay, accepted!")
                session = action.get("session")
                
                if session and session.is_offer():
                    answer = self.update_session(session)
                    self.forward(dict(type="session", session=answer))
                    
                break
            elif action["type"] == "session":
                session = action.get("session")
                
                if session.is_offer():
                    # This is the offer from an RPR, we'll answer in a PRACK request
                    offer = session
                    answer = self.update_session(offer)
                    self.forward(dict(type="session", session=answer))
                    
                    # Then send another offer to force an UPDATE
                    offer = answer.flipped()
                    self.forward(dict(type="session", session=offer))
                else:
                    # This is the answer from the UPDATE response, no need to process it
                    pass
            else:
                self.logger.error("Hm, we got: %s!" % action["type"])
            
        #session = action.get("session")
        #if session and session.is_offer():
        #    answer = self.update_session(session)
        #    self.forward(dict(type="session", session=answer))

        # Be more flexible here!
        yield from self.idle()

        self.logger.debug("Caller done.")


class TestRecordManager(RecordManager):
    pass
        

class VoicemailEventSource(MessageSummaryEventSource):
    def identify(self, params):
        self.mailbox = params["mailbox"]

        self.state = 0
        zap.time_slot(30, True).plug(self.fake)
        
        return self.mailbox
        
        
    def fake(self):
        self.notify_all()
        self.state += 1

        
    def get_message_state(self):
        return dict(voice=self.state % 2, voice_old=self.state / 2 % 2)


class BusylampEventSource(DialogEventSource):
    def identify(self, params):
        self.set_entity(params["entity"])

        self.calls_by_number = {}
        #self.call_state = None
        
        self.state = 0
        #zap.time_slot(30, True).plug(self.fake)

        return self.entity
        
        
    def update(self, call_number, is_outgoing, is_confirmed):
        if is_outgoing is None and is_confirmed is None:
            self.calls_by_number.pop(call_number)
        else:
            self.calls_by_number[call_number] = dict(is_outgoing=is_outgoing, is_confirmed=is_confirmed)
            
        self.logger.info("%s: %s" % (self.entity, self.calls_by_number))
        
        #if (False, False) in self.calls_by_number.values():
        #    self.call_state = False
        #elif self.calls_by_number:
        #    self.call_state = True
        #else:
        #    self.call_state = None
            
        self.notify_all()
            
        
    def fake(self):
        self.notify_all()
        self.state += 1
        
        
    def get_dialog_state(self):
        return self.calls_by_number
        
        #if self.state % 3 == 0:
        #    return dict()
        #elif self.state % 3 == 1:
        #    return dict(one=dict(is_outgoing=False, is_confirmed=False))
        #else:
        #    return dict(one=dict(is_outgoing=False, is_confirmed=True))
            

class TestSubscriptionManager(SubscriptionManager):
    def identify_event_source(self, params):
        event = params["event"]
        from_uri = params["from"].uri._replace(params={})
        to_uri = params["to"].uri._replace(params={})
        
        if event == "message-summary" and to_uri.username == "phonebox":
            return "voicemail", from_uri.username
            
        if event == "dialog":
            return "busylamp", to_uri.username
            
        return None
        
        
    def make_event_source(self, type):
        if type == "voicemail":
            return VoicemailEventSource()
        elif type == "busylamp":
            return BusylampEventSource()
        else:
            return None


class TestController(Controller):
    def __init__(self, ports):
        Controller.__init__(self)
        
        # Must use IP4 addresses or FQDN in SDP, so let's go with IP4
        # Media host may be different from the signaling host
        self.media_addresses = set(Addr(MEDIA_HOST, port).resolved() for port in ports)
        
    
    def allocate_media_address(self, mgw_sid):
        return self.media_addresses.pop()
    
    
    def deallocate_media_address(self, addr):
        self.media_addresses.add(addr)
        
        
class TestLine(Bridge):
    def identify(self, params):
        self.is_outgoing = None  # if the device dialed out
        self.is_confirmed = None
        
        self.addr = params["addr"]
        self.username = params["username"]
        
        return "%s@%s" % (self.username, self.addr)
        
        
    def update_busylamp_state(self):
        es = self.ground.switch.subscription_manager.get_event_source("busylamp", self.username)
        
        if es:
            es.update(self.call_info["number"], self.is_outgoing, self.is_confirmed)
        
        
    def process_dial(self, action):
        ctx = action["ctx"]
        #self.addr = ctx.pop("line_addr", None)
        #self.username = ctx.pop("line_username", None)
        
        src_username = ctx["src_username"]
        src_addr = ctx["src_addr"]
        src_name = ctx["src_name"]
        
        dst_username = ctx["dst_username"]
        dst_addr = ctx["dst_addr"]
        
        if self.username != dst_username or self.addr != dst_addr:
            self.is_outgoing = True
            self.is_confirmed = False
            self.update_busylamp_state()
            self.dial(action)
            return
            
        self.is_outgoing = False
        self.is_confirmed = False
        self.update_busylamp_state()
        
        record_uri = Uri(dst_addr, dst_username)
        self.logger.debug("Checking registered SIP contact: %s" % (record_uri,))
        contacts = self.ground.switch.record_manager.lookup_contacts(record_uri)
        
        if len(contacts) == 1:
            contact = contacts[0]
        
            dst = {
                'type': "sip",
                'uri': contact.uri,
                'hop': contact.hop,
                'from': Nameaddr(Uri(src_addr, src_username), src_name),
                'to': Nameaddr(Uri(dst_addr, dst_username)),
                'route': []
                #'alert_info': "<http://www.notused.com>;info=alert-autoanswer;delay=0"  # FIXME
            }
        
            #self.dial("sip", dict(action, ctx=dst))
            self.dial(action, **dst)
        else:
            self.logger.debug("Has %d registered SIP contacts: %s" % (len(contacts), record_uri))
            self.reject_incoming_leg(Status(404))
            
            
    def process_leg_transfer(self, li, action):
        if not self.is_outgoing and li > 0:
            self.forward(0, action)
        elif self.is_outgoing and li == 0:
            self.forward(max(self.legs.keys()), action)
        else:
            Bridge.process_leg_transfer(self, li, action)
            
            
    def do_slot(self, li, action):
        type = action["type"]
        
        if type == "accept":
            self.is_confirmed = True
            self.update_busylamp_state()
        elif type in ("reject", "hangup"):
            self.is_outgoing = None
            self.is_confirmed = None
            self.update_busylamp_state()
            
        return Bridge.do_slot(self, li, action)
    

class TestSwitch(Switch):
    def __init__(self, local_addr, mgw_addr, media_ports):
        local_addr.assert_resolved()
        mgw_addr.assert_resolved()
        
        record_manager = TestRecordManager(proxy(self))
        subman = TestSubscriptionManager(proxy(self))
        mgc = TestController(media_ports)

        Switch.__init__(
            self,
            record_manager=record_manager, registration_manager=None,
            subscription_manager=subman,
            dialog_manager=None, mgc=mgc, account_manager=None
        )
        
        self.local_addr = local_addr
        self.mgw_addr = mgw_addr


    def start(self):
        self.mgc.add_mgw_addr(self.mgw_addr)
        
        hop = Hop("UDP", "eth0", self.local_addr, None)
        self.transport_manager.add_hop(hop)
        
        hop = Hop("TCP", "eth0", self.local_addr, None)
        self.transport_manager.add_hop(hop)


    def make_party(self, type):
        if type == "caller":
            return CallerEndpoint()
        elif type == "callee":
            return CalleeEndpoint()
        elif type == "unreachable":
            return UnreachableEndpoint()
        elif type == "ringing":
            return RingingEndpoint()
        elif type == "line":
            return TestLine()
        else:
            return Switch.make_party(self, type)


    def reregister_snom(self, addr, line):
        post_data = "REREGISTER%3A1=Re-Register"
        url = "http://%s/line_login.htm?l=%d" % (addr, line)
        os.system("wget -q --output-document=/dev/null --post-data='%s' '%s'" % (post_data, url))


    def add_record_account(self, uri, authname, ha1, policy, hops=[]):
        if not self.account_manager.get_account(authname):
            self.account_manager.add_account(authname, ha1)
            
        record = self.record_manager.add_record(uri, authname, policy)
        
        for hop in hops:
            record.add_static_contact(uri, hop)  # assume same contact uri as the aor


def mkctx(src):
    if src["type"] != "sip":
        raise Exception("Uh-oh, not a SIP-like caller?")
    
    return dict(
        src_addr=src["from"].uri.addr,
        src_username=src["from"].uri.username,
        src_name=src["from"].name,
        dst_addr=src["to"].uri.addr,
        dst_username=src["to"].uri.username,
        dst_name=src["to"].name
    )
    

class SwitchA(TestSwitch):
    class ARouting(Routing):
        def process_dial(self, action):
            ctx = action["ctx"]
            
            if not ctx:
                ctx.update(mkctx(action["src"]))
                
                self.dial(action, "line", addr=ctx["src_addr"], username=ctx["src_username"])
                return

            if ctx["dst_username"] in ("222", "333"):
                self.dial(action, "callee")
            else:
                self.dial(action, "line", addr=ctx["dst_addr"], username=ctx["dst_username"])
            

    def start(self):
        TestSwitch.start(self)
        
        # CALLEE lives on switch-b, but registers here to take calls from here
        callee_uri = Uri(Addr(A_DOMAIN, None), CALLEE_NUMBER)
        self.add_record_account(callee_uri, B_AUTHNAME, B_HA1, Record.AUTH_IF_UNREGISTERED)
        #self.account_manager.add_account(callee_uri, "Callee", Account.AUTH_IF_UNREGISTERED, B_CRED[0], B_CRED[1])
        
        # SNOM lives on its own device, but also registers here
        snom_uri = Uri(Addr(A_DOMAIN, None), SNOM_NUMBER)
        self.add_record_account(snom_uri, SNOM_AUTHNAME, SNOM_HA1, Record.AUTH_IF_UNREGISTERED)
        #self.account_manager.add_account(snom_uri, "Snom", Account.AUTH_IF_UNREGISTERED, SNOM_CRED[0], SNOM_CRED[1])
        
        # Allow calls from anyone on switch-b as long as they use this hop
        b_uri = Uri(Addr(B_DOMAIN, None), None)
        hop1 = Hop('UDP', 'eth0', A_ADDR.resolved(), B_ADDR.resolved())
        hop2 = Hop('TCP', 'eth0', A_ADDR.resolved(), B_ADDR._replace(port=None).resolved())
        self.add_record_account(b_uri, B_AUTHNAME, B_HA1, Record.AUTH_BY_HOP, [ hop1, hop2 ])
        #b_uri, "B", Account.AUTH_BY_HOP, None, None, hops=[ hop1, hop2 ])
        
        # Allow us to register at other places
        self.account_manager.set_our_credentials(A_AUTHNAME, A_HA1)

        # Add a voicemail box to monitor
        self.subscription_manager.add_event_source("voicemail", dict(mailbox="phone"))
        
        # Add a line state
        self.subscription_manager.add_event_source("busylamp", dict(entity="201"))
        self.subscription_manager.add_event_source("busylamp", dict(entity="phone"))

        #if TEST == TEST_DIALOUT:
        #    zap.time_slot(2).plug(self.test_snoming)
        

    def make_party(self, type):
        if type == "routing":
            return self.ARouting()
        else:
            return TestSwitch.make_party(self, type)

        
    def test_snoming(self):
        # We need the "support broken registrar" option, otherwise we'd have to guess
        # a random line id. Also, the hop guessing also works for UDP.
        snom_uri = Uri(Addr(A_DOMAIN, None), SNOM_NUMBER)
        snom_contact = Uri(SNOM_ADDR, SNOM_NUMBER)
        snom_hop = Hop('UDP', 'eth0', A_ADDR.resolved(), SNOM_ADDR.resolved())
        
        self.record_manager.emulate_registration(snom_uri, snom_contact, 60, snom_hop)
        
        


class SwitchB(TestSwitch):
    class BRouting(PlannedRouting):
        def plan(self):
            self.logger.debug("Routing plan started.")
            li, action = yield from self.wait_leg_action()
            ctx = action["ctx"]
            
            if not ctx:
                ctx.update(mkctx(action["src"]))

                #self.dial(action, "line", addr=ctx["src_addr"], username=ctx["src_username"])
                self.dial(action, "record", id="prekord")
                return

            src_username = ctx["src_username"]
            src_addr = ctx["src_addr"]
            src_name = ctx["src_name"]
        
            dst_username = ctx["dst_username"]
            dst_addr = ctx["dst_addr"]
            
            if dst_username == CALLEE_NUMBER:
                ctx["dst_username"] = "444"
                self.dial(action, "record", id="rekord")
            elif dst_username == "444":
                self.dial(action, "unreachable")
                self.dial(action, "ringing")
                self.dial(action, "callee")
            elif dst_username == SNOM_NUMBER:
                dst = {
                    'type': "sip",
                    'uri': Uri(A_ADDR, SNOM_NUMBER),
                    #'hop': contact.hop,
                    'from': Nameaddr(Uri(src_addr, src_username), src_name),
                    'to': Nameaddr(Uri(dst_addr, dst_username)),  # FIXME: shouldn't be our addr!
                    'route': []
                }
                
                #action2 = deepcopy(action)
                #action2["ctx"]["uri"] = Uri(A_ADDR, SNOM_NUMBER)
                #action2["ctx"]["uri"] = Uri(A_ADDR, SNOM_NUMBER, params=dict(transport="TCP"))
                #self.dial("sip", dict(action, ctx=dst))
                self.dial(action, **dst)
            
            
    def start(self):
        TestSwitch.start(self)
        
        phone_uri = Uri(Addr(A_DOMAIN, None), SNOM_NUMBER)
        self.add_record_account(phone_uri, A_AUTHNAME, A_HA1, Record.AUTH_IF_UNREGISTERED)
        
        #self.account_manager.add_account(phone_uri, "Phone", Account.AUTH_IF_UNREGISTERED, A_CRED[0], A_CRED[1])
        
        self.account_manager.set_our_credentials(B_AUTHNAME, B_HA1)

        zap.time_slot(1).plug(self.reregister_snom, addr=SNOM_WEB, line=1)

        if TEST == TEST_DIALOUT:
            zap.time_slot(3).plug(self.test_dialing)
            
        if TEST == TEST_DIALIN:
            zap.time_slot(3).plug(self.test_registering)


    def make_party(self, type):
        if type == "routing":
            return self.BRouting()
        else:
            return TestSwitch.make_party(self, type)


    def test_registering(self):
        self.logger.debug("Registering to Switch A.")

        self.registration_manager.start_registration(
            registrar_uri=Uri(A_ADDR),
            record_uri=Uri(Addr(A_DOMAIN, None), CALLEE_NUMBER)
        )
        
        
    def test_dialing(self):
        self.logger.debug("Dialing begins.")

        self.start_call("caller")


def main():
    # By using only local variables, they'll be released when exiting this function,
    # so various __del__ methods will run before interpreter shutdown, when even
    # logging is disfunctional.
    
    setup_logging()
    logging.debug("Hello!")

    mgw = MediaGateway(MGW_ADDR.resolved())
    mgw.set_oid(Oid("mgw"))
    mgw.set_name(Oid("the-mgw"))

    switch_a = SwitchA(A_ADDR.resolved(), MGW_ADDR.resolved(), range(30000, 30020, 2))
    switch_a.set_oid(Oid().add("switch", "a"))
    switch_a.set_name("switch-a")
    switch_a.start()
    
    switch_b = SwitchB(B_ADDR.resolved(), MGW_ADDR.resolved(), range(40000, 40020, 2))
    switch_b.set_oid(Oid().add("switch", "b"))
    switch_b.set_name("switch-b")
    switch_b.start()

    try:
        zap.loop()
    except Exception:
        logging.critical("Crashed!")
        my_exchandler(*sys.exc_info())
    else:
        logging.critical("Shutting down.")
    finally:
        # The exception object is already gone here
        
        del switch_b
        del switch_a
        del mgw
    
        logging.debug("Bye!")
        logging.shutdown()


main()
