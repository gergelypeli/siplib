#! /usr/bin/python3

import logging
import logging.config
from copy import deepcopy
import sys
from weakref import proxy

from format import Addr, Uri, Nameaddr, Status, SipError, Hop
from leg import PlannedEndpoint, SimpleRouting, PlannedRouting
from sdp import Sdp
from authority import Authority
from registrar import RecordManager
from account import Account
from util import setup_logging, build_oid, my_exchandler
from mgw import MediaGateway
from mgc import Controller  #, PlayerMediaLeg  #, EchoMediaLeg
from switch import Switch
import zap
import resolver

TEST_DIALIN = 1
TEST_DIALOUT = 2
TEST = TEST_DIALOUT

HOST = "otthon"
A_ADDR = Addr(HOST, 5060)
B_ADDR = Addr(HOST, 5062)

A_DOMAIN = "a.switch"
B_DOMAIN = "b.switch"

CALLER_NAMEADDR = Nameaddr(Uri(Addr(B_DOMAIN, None), "caller"), "Caller")

CALLEE_NAMEADDR = Nameaddr(Uri(Addr(B_DOMAIN, None), "callee"), "Callee")

A_CRED = ("A_AUTHNAME", "A_HA1")
B_CRED = ("B_AUTHNAME", "B_HA1")

SNOM_NUMBER = "phone"
SNOM_CRED = ("phone", "38450ead4036feb352c45462d8008511")  # md5(phone:a.switch:secret)

CALLEE_NUMBER = "555"

CALLER_SDP = Sdp.parse("""
v=0
o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5
s=SDP Seminar
i=A Seminar on the session description protocol
u=http://www.example.com/seminars/sdp.pdf
e=j.doe@example.com (Jane Doe)
c=IN IP4 224.2.17.12
t=2873397496 2873404696
a=recvonly
m=audio 49170 RTP/AVP 0
m=video 51372 RTP/AVP 99
a=rtpmap:99 h263-1998/90000
""")

MGW_HOST = "localhost"
MGW_ADDR = Addr(MGW_HOST, 20000)

MEDIA_HOST = "otthon"


class TestEndpoint(PlannedEndpoint):
    def wait_this_action(self, action_type):
        action = yield from self.wait_action()
        assert action and action["type"] == action_type
        return action
        

    def update_session(self, offer):
        if not self.leg.media_legs:
            media_leg = self.leg.make_media_leg("player")
            self.leg.set_media_leg(0, media_leg)
            media_leg.play("playback.wav", ("PCMA", 8000, 1, None), volume=0.2, fade=3)

        answer = deepcopy(offer)
        answer["is_answer"] = True
        
        for c in answer["channels"]:
            c["send"], c["recv"] = c["recv"], c["send"]
            
        return answer
        
        
    def idle(self):
        while True:
            action = yield from self.wait_action()
            
            if action["type"] == "session":
                answer = self.update_session(action["session"])
                self.leg.forward(dict(type="session", session=answer))
            elif action["type"] == "tone":
                self.logger.debug("Okay, got a tone %s, fading out..." % action["name"])
                break
            else:
                self.logger.debug("Don't know what to do with %s, continuing..." % action["type"])
        
        if self.leg.media_legs:
            self.leg.media_legs[0].play(volume=0, fade=3)
            yield from self.sleep(3)
            
        self.leg.forward(dict(type="hangup"))


class UnreachableEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Unreachable endpoint created.")
        
        yield from self.wait_this_action("dial")
        self.logger.debug("Got dial, but not answering anything.")

        yield from self.wait_this_action("hangup")
        self.logger.debug("And now the caller hung up.")


class RejectingEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Rejecting endpoint created.")
        
        yield from self.wait_this_action("dial")
        self.logger.debug("Got dial, but not now rejecting it.")

        self.leg.forward(dict(type="reject", status=Status(603)))
        self.logger.debug("And now done.")


class RingingEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Ringing endpoint created.")
        
        yield from self.wait_this_action("dial")
        self.logger.debug("Got dial, now ringing forever.")

        self.leg.forward(dict(type="ring"))

        yield from self.wait_this_action("hangup")
        self.logger.debug("And now the caller hung up.")


class CalleeEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Callee created.")
        
        action = yield from self.wait_this_action("dial")
        offer = action.get("session")
        self.logger.debug("Got offer:\n%s" % repr(offer))
        
        yield from self.sleep(1)
        self.leg.forward(dict(type="ring"))
        
        yield from self.sleep(1)
        
        answer = self.update_session(offer)
        self.leg.forward(dict(type="accept", session=answer))

        yield from self.idle()
        
        self.logger.debug("Callee done.")


class CallerEndpoint(TestEndpoint):
    # TODO: call the phone without SDP!
    
    def plan(self):
        self.logger.debug("Caller created")
        
        address = yield from resolver.wait_resolve("index.hu")
        self.logger.debug("Resolved index.hu asynchronously to: %s" % address)
        
        ctx = {
            'from': CALLER_NAMEADDR,
            'to': Nameaddr(Uri(Addr(A_DOMAIN, None), SNOM_NUMBER))
        }
        
        offer = None  # FIXME: make one from CALLER_SDP!
        self.leg.forward(dict(type="dial", ctx=ctx, session=offer))

        while True:
            action = yield from self.wait_action()
        
            if action["type"] == "reject":
                self.logger.error("Oops, we got rejected!")
                return
            elif action["type"] == "accept":
                self.logger.error("Yay, accepted!")
                break
            else:
                self.logger.error("Hm, we got: %s!" % action["type"])
            
        offer = action.get("session")
        answer = self.update_session(offer)
        
        self.leg.forward(dict(type="session", session=answer))

        # Be more flexible here!
        yield from self.idle()

        self.logger.debug("Caller done.")


class TestRecordManager(RecordManager):
    pass
        

class TestAuthority(Authority):
    pass


class TestController(Controller):
    def __init__(self, ports):
        super().__init__()
        
        # Must use IP4 addresses or FQDN in SDP, so let's go with IP4
        # Media host may be different from the signaling host
        self.media_addresses = set(Addr(MEDIA_HOST, port).resolved() for port in ports)
        
    
    def allocate_media_address(self, mgw_sid):
        return self.media_addresses.pop()
    
    
    def deallocate_media_address(self, addr):
        self.media_addresses.add(addr)
        
        
class TestRouting(SimpleRouting):
    def route(self, action):
        ctx = action["ctx"]
        to_uri = ctx["to"].uri
        self.logger.debug("Checking registered SIP contact: %s" % (to_uri,))
        contacts = self.call.switch.record_manager.lookup_contacts(to_uri)
            
        if len(contacts) == 1:
            uri, hop = contacts[0]
            
            out_ctx = {
                'uri': uri,  # Only update the RURI for dialing out
                'hop': hop,
                'from': ctx["from"],
                'to': ctx["to"]
            }
            
            out_action = dict(action, ctx=out_ctx)
            self.dial("sip", out_action)
        else:
            self.logger.debug("Has %d registered SIP contacts: %s" % (len(contacts), to_uri,))
            raise SipError(Status(404))


class TestSwitch(Switch):
    def __init__(self, local_addr, mgw_addr, media_ports):
        local_addr.assert_resolved()
        mgw_addr.assert_resolved()
        
        record_manager = TestRecordManager(proxy(self))
        authority = TestAuthority()
        mgc = TestController(media_ports)
        mgc.add_mgw_addr(mgw_addr)

        Switch.__init__(
            self,
            record_manager=record_manager, authority=authority, registration_manager=None,
            dialog_manager=None, mgc=mgc, account_manager=None
        )

        self.transport_manager.add_udp_transport(local_addr, "eth0")


    def make_thing(self, type):
        if type == "routing":
            return TestRouting()
        elif type == "callee":
            return CalleeEndpoint()
        elif type == "unreachable":
            return UnreachableEndpoint()
        elif type == "ringing":
            return RingingEndpoint()
        else:
            return Switch.make_thing(self, type)


class SwitchA(TestSwitch):
    def __init__(self, *args):
        super().__init__(*args)
        
        # CALLEE lives on switch-b, but registers here to take calls from here
        callee_uri = Uri(Addr(A_DOMAIN, None), CALLEE_NUMBER)
        self.account_manager.add_account(callee_uri, "Callee", Account.AUTH_IF_UNREGISTERED, B_CRED[0], B_CRED[1])
        
        # SNOM lives on its own device, but also registers here
        snom_uri = Uri(Addr(A_DOMAIN, None), SNOM_NUMBER)
        self.account_manager.add_account(snom_uri, "Snom", Account.AUTH_IF_UNREGISTERED, SNOM_CRED[0], SNOM_CRED[1])
        
        # Allow calls from anyone on switch-b as long as they use this hop
        b_uri = Uri(Addr(B_DOMAIN, None), None)
        hop = Hop('eth0', A_ADDR.resolved(), B_ADDR.resolved())
        self.account_manager.add_account(b_uri, "B", Account.AUTH_BY_HOP, None, None, hops=[ hop ])
        
        # Allow us to register at other places
        self.account_manager.set_our_credentials(*A_CRED)

        if TEST == TEST_DIALOUT:
            zap.time_slot(2).plug(self.test_snoming)
        
        
    def test_snoming(self):
        snom_uri = Uri(Addr(A_DOMAIN, None), SNOM_NUMBER)
        snom_addr = Addr("192.168.1.8", 1024)  # Quite fake
        snom_contact = Uri(snom_addr, SNOM_NUMBER)
        snom_hop = Hop('eth0', A_ADDR.resolved(), snom_addr.resolved())
        
        self.record_manager.emulate_registration(snom_uri, snom_contact, 60, snom_hop)
        
        


class SwitchB(TestSwitch):
    class Routing(PlannedRouting):
        def plan(self):
            self.logger.debug("Routing plan started.")
            
            li, action = yield from self.wait_leg_action()
            ctx = action["ctx"]
            to = ctx["to"]
            
            if to.uri.user == CALLEE_NUMBER:
                #self.bridge("record")
                to2 = to._replace(uri=to.uri._replace(user="444"))
                action2 = dict(action, ctx=dict(ctx, to=to2))
                self.dial("record", action2)
            elif to.uri.user == "444":
                self.dial("unreachable", action)
                self.dial("ringing", action)
                self.dial("callee", action)
            elif to.uri.user == SNOM_NUMBER:
                action2 = dict(action, ctx=dict(ctx, uri=Uri(A_ADDR, SNOM_NUMBER)))
                self.dial("sip", action2)
            
            
    def __init__(self, *args):
        super().__init__(*args)
        
        phone_uri = Uri(Addr(A_DOMAIN, None), SNOM_NUMBER)
        
        self.account_manager.add_account(phone_uri, "Phone", Account.AUTH_IF_UNREGISTERED, A_CRED[0], A_CRED[1])
        
        self.account_manager.set_our_credentials(*B_CRED)

        if TEST == TEST_DIALOUT:
            zap.time_slot(3).plug(self.test_dialing)
            
        if TEST == TEST_DIALIN:
            zap.time_slot(1).plug(self.test_registering)


    def make_thing(self, type):
        if type == "routing":
            return self.Routing()
        else:
            return TestSwitch.make_thing(self, type)


    def test_registering(self):
        self.logger.debug("Registering to Switch A.")

        self.registration_manager.start_registration(
            registrar_uri=Uri(A_ADDR),
            record_uri=Uri(Addr(A_DOMAIN, None), CALLEE_NUMBER)
        )
        
        
    def test_dialing(self):
        self.logger.debug("Dialing begins.")

        incoming_thing = CallerEndpoint()
        self.start_call(incoming_thing)


def main():
    # By using only local variables, they'll be released when exiting this function,
    # so various __del__ methods will run before interpreter shutdown, when even
    # logging is disfunctional.
    
    setup_logging()
    logging.debug("Hello!")

    mgw = MediaGateway(MGW_ADDR.resolved())
    mgw.set_oid("mgw")
    mgw.set_name("the-mgw")
    mgw.start()

    switch_a = SwitchA(A_ADDR.resolved(), MGW_ADDR.resolved(), range(30000, 30020, 2))
    switch_a.set_oid(build_oid(None, "switch", "a"))
    switch_a.set_name("switch-a")
    switch_a.start()
    
    switch_b = SwitchB(B_ADDR.resolved(), MGW_ADDR.resolved(), range(40000, 40020, 2))
    switch_b.set_oid(build_oid(None, "switch", "b"))
    switch_b.set_name("switch-b")
    switch_b.start()

    try:
        zap.loop()
    except KeyboardInterrupt:
        pass
    except Exception:
        logging.critical("Crashed!")
        my_exchandler(*sys.exc_info())
    finally:
        # The exception object is already gone here
        
        del switch_b
        del switch_a
        del mgw
    
        logging.debug("Bye!")


try:
    main()
finally:
    logging.shutdown()
