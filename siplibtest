#! /usr/bin/python3

from __future__ import print_function, unicode_literals
from datetime import timedelta
import logging
from async import Metapoll, WeakMethod, Weak

from format import Addr, Uri, Nameaddr, Status
from transport import UdpTransport
from transactions import TransactionManager, make_simple_response
from dialog import Dialog, DialogManager
from leg import SipLeg, PlannedLeg, create_uninvited_leg
from call import Call, Routing
from sdp import Sdp
from authority import Authority
from registrar import RegistrationManager, RecordManager
from util import resolve, setup_exchandler
from mgw import MediaGateway
from mgc import Controller, PlayerMediaLeg

HOST = "otthon"
a_addr = Addr(HOST, 5060)
b_addr = Addr(HOST, 5062)

a_registrar = Uri(a_addr)

caller_uri = Uri(a_addr, "caller")
caller_name = "Caller"
caller_nameaddr = Nameaddr(caller_uri, caller_name)

callee_uri = Uri(b_addr, "callee")
callee_name = "Callee"
callee_nameaddr = Nameaddr(callee_uri, callee_name)

#wrong_uri = Uri(local_addr, "wrong")

caller_cred = ("CALLER_AUTHNAME", "CALLER_HA1")
callee_cred = ("CALLEE_AUTHNAME", "CALLEE_HA1")
phone_cred = ("phone", "29947c88227ea55104f09dbdd5e6c48e")  # md5(phone:A-NET:secret)

caller_audio_addr = (HOST, 10000)
caller_video_addr = (HOST, 10001)

caller_sdp = Sdp.parse("""
v=0
o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5
s=SDP Seminar
i=A Seminar on the session description protocol
u=http://www.example.com/seminars/sdp.pdf
e=j.doe@example.com (Jane Doe)
c=IN IP4 224.2.17.12
t=2873397496 2873404696
a=recvonly
m=audio 49170 RTP/AVP 0
m=video 51372 RTP/AVP 99
a=rtpmap:99 h263-1998/90000
""")

MEDIA_HOST = "otthon"
MGW_HOST = "localhost"
MGC1_HOST = "localhost"
MGC2_HOST = "localhost"
mgw_addr = Addr(MGW_HOST, 20000)
mgc1_addr = Addr(MGC1_HOST, 20001)
mgc2_addr = Addr(MGC2_HOST, 20002)


def sleep(secs, method):
    metapoll.register_timeout(timedelta(seconds=secs), WeakMethod(method))


class CalleeLeg(PlannedLeg):
    def __init__(self, call, metapoll):
        super(CalleeLeg, self).__init__(call, metapoll)
        
        
    def plan(self, planner):
        print("Callee created.")
        
        action = yield from planner.wait_action("dial")
        self.offer = action.get("offer")
        print("Got offer:\n%s" % repr(self.offer))
        
        yield from planner.sleep(1)
        self.report(dict(type="ring"))
        
        yield from planner.sleep(1)
        answer = self.make_answer(self.offer)
        self.report(dict(type="accept", answer=answer))
        self.media_legs.append(PlayerMediaLeg(self.call.mgc))
        self.media_legs[0].play("playback.wav", ("PCMA", 8000), volume=0.2, fade=5)
        self.refresh_media()
        
        yield from planner.sleep(5)
        self.media_legs[0].play(volume=0, fade=5)
        self.refresh_media()
        
        yield from planner.sleep(5)
        self.report(dict(type="hangup"))

        print("Callee done.")
        

    def make_answer(self, offer):
        return offer


class CallerLeg(PlannedLeg):
    def plan(self, planner):
        print("Caller created")
        
        yield from planner.sleep(0)
        self.ctx["from"] = Nameaddr(caller_uri, caller_name)
        self.ctx["to"] = Nameaddr(callee_uri)
        self.report(dict(type="dial", ctx=self.ctx, offer=caller_sdp))

        action = yield from planner.wait_action("accept")
        print("Accepted with SDP:\n%s" % repr(action.get("answer")))

        action = yield from planner.expect("action")
        assert action["type"] == "hangup"
        
        print("Caller done.")
        #yield from planner.sleep(3)
        #self.leg.do(dict(type="hangup"))


class TestAuthority(Authority):
    def __init__(self, realm, record_manager):
        super(TestAuthority, self).__init__(realm)
        
        self.record_manager = record_manager
        self.users = {}
        self.myuser = None
        
        
    def adduser(self, authname, ha1):
        self.users[authname] = ha1
        
        
    def setuser(self, authname, ha1):
        self.myuser = (authname, ha1)
        

    def authenticate(self, params):
        method = params["method"]
        from_uri = params["from"].uri
        hop = params["hop"]
        contact_hops = self.record_manager.lookup_contact_hops(from_uri)
        
        if method != "REGISTER" and hop in contact_hops:
            print("Trusting registered user '%s'" % (from_uri,))
            return True
        
        authname = self.get_digest_authname(params)
        if authname in self.users:
            return self.check_digest_ha1(params, self.users[authname])
            
        return False
            
            
    def identify(self, params):
        return self.myuser


class TestController(Controller):
    def __init__(self, metapoll, mgc_addr, mgw_addr, ports):
        super().__init__(metapoll, mgc_addr)
        
        self.mgw_addr = resolve(mgw_addr)
        
        # Must use IP4 addresses or FQDN in SDP, so let's go with IP4
        # Media host may be different from the signaling host
        self.media_addresses = set(resolve(Addr(MEDIA_HOST, port)) for port in ports)
        
    
    def allocate_media_address(self, channel_index):
        return self.media_addresses.pop()
    
    
    def deallocate_media_address(self, addr):
        self.media_addresses.add(addr)
        
        
    def select_gateway_address(self, affinity=None):
        return self.mgw_addr
        
    
    #def make_media_channel(self):
    #    # Must use unique MGW addresses for Msgp
    #    key = chr(self.mgc_addr[1] % 10 + 96)
    #    context_id = "ctx-%s-%d" % (key, self.next_ctx)
    #    sid = (resolve(mgw_addr), context_id)  # TODO: make Sid class?
    #    self.next_ctx += 1
    #    
    #    return ProxiedMediaChannel(Weak(self), sid)
        
        
class TestRouting(Routing):
    def __init__(self, switch, call, report, incoming_leg):
        super(TestRouting, self).__init__(call, report, incoming_leg)
        self.switch = switch
        

    def route_call(self, ctx):
        to_uri = ctx["to"].uri
        print("Checking registered SIP contact: %s" % (to_uri,))
        contacts = self.switch.record_manager.lookup_contact_uris(to_uri)
            
        if contacts:
            # TODO: do we care about the ctx in the outgoing leg?
            ctx["to"] = Nameaddr(contacts[0])  # TODO: warn if more
            outgoing_dialog = Dialog(Weak(self.switch.dialog_manager))
            outgoing_leg = SipLeg(self.call, outgoing_dialog)
            return outgoing_leg
        else:
            print("No such registered SIP contact: %s" % (to_uri,))
            raise Exception("Routing failed!")  # TODO: reject!


class TestCall(Call):
    RoutingClass = TestRouting
    
    def __init__(self, switch, mgc, finish_handler):
        super(TestCall, self).__init__(mgc, finish_handler)
        self.switch = switch


    def make_routing(self, incoming_leg):
        return self.RoutingClass(self.switch, Weak(self), WeakMethod(self.routed), incoming_leg)
    

class Switch(object):
    CallClass = TestCall
    
    def __init__(self, metapoll, local_addr, mgc_addr, mgw_addr, media_ports, realm):
        self.metapoll = metapoll
        self.transport = UdpTransport(metapoll, local_addr, WeakMethod(self.reception))
        self.transaction_manager = TransactionManager(local_addr, WeakMethod(self.transport.send))
        self.record_manager = RecordManager(WeakMethod(self.transaction_manager.send_message))
        self.authority = TestAuthority(realm, Weak(self.record_manager))  # TODO: domain2realm!
        self.registration_manager = RegistrationManager(
            WeakMethod(self.transaction_manager.send_message),
            WeakMethod(self.transport.get_hop),
            WeakMethod(self.authority.provide_auth)
        )
        self.dialog_manager = DialogManager(
            local_addr,
            WeakMethod(self.transaction_manager.send_message),
            WeakMethod(self.transport.get_hop),
            WeakMethod(self.authority.provide_auth)
        )
        self.mgc = TestController(metapoll, mgc_addr, mgw_addr, media_ports)

        self.calls = []  # TODO: make it a dict with call identifiers!

        metapoll.register_timeout(timedelta(seconds=0.2), WeakMethod(self.transaction_manager.maintenance), repeat=True)

    
    def reject_request(self, msg, status):
        if msg:
            response = make_simple_response(msg, status)
            self.transaction_manager.send_message(response, msg)


    def challenge_request(self, msg, challenge):
        if msg:
            response = make_simple_response(msg, Status(401, "Hey"), challenge)
            self.transaction_manager.send_message(response, msg)


    # Interface to Call
    #def make_media_channel(self, media_legs):
    #    return self.mgc.make_media_channel(media_legs)
        
        
    def make_call(self):
        return self.CallClass(Weak(self), Weak(self.mgc), WeakMethod(self.finish_call))
        
        
    def start_call(self, params):  # TODO: params unused
        call = self.make_call()
        self.calls.append(call)

        incoming_dialog = Dialog(Weak(self.dialog_manager))
        incoming_leg = SipLeg(call, incoming_dialog)
        
        call.start_routing(incoming_leg)
        return WeakMethod(incoming_dialog.recv_request)
    

    def finish_call(self, call):
        # TODO: Call should be smarter!
        
        def ugly_delayed_finish():
            print("Finishing call")
            self.calls.remove(call)
            
        self.metapoll.register_timeout(timedelta(seconds=1), ugly_delayed_finish)
        

    def process_request(self, params):
        if params["uri"].schema != "sip":
            WeakMethod(self.reject_request, Status(404, "Not found"))
            
        challenge = self.authority.require_auth(params)
        if challenge:
            return WeakMethod(self.challenge_request, challenge)

        if params["method"] == "REGISTER":
            return self.record_manager.match_incoming_request(params)

        report = self.dialog_manager.match_incoming_request(params)
        if report:
            return report
    
        if params["method"] == "INVITE" and "tag" not in params["to"].params:
            return self.start_call(params)
    
        return WeakMethod(self.reject_request, Status(400, "Bad request"))
        

    def reception(self, params):
        #print("Got message from transport.")
        #print("Req params: %s" % req_params)
        uninvite_params = self.transaction_manager.match_uninvited_response(params)
        if uninvite_params:
            create_uninvited_leg(uninvite_params)
    
        if self.transaction_manager.match_incoming_message(params):
            return

        report = self.process_request(params)
        
        self.transaction_manager.create_incoming_request(params, report)


class SwitchA(Switch):
    def __init__(self, metapoll, *args):
        super(SwitchA, self).__init__(metapoll, *args)
        
        self.authority.setuser(*caller_cred)
        self.authority.adduser(*callee_cred)
        self.authority.adduser(*phone_cred)

        #metapoll.register_timeout(timedelta(seconds=2), WeakMethod(self.test_dialing))
        
        
    def test_dialing(self):
        print("Dialing begins.")

        #incoming_leg = CallerLeg()
        #self.start_call(incoming_leg)
        
        #incoming_leg.dial()
    

class SwitchB(Switch):
    class CallClass(TestCall):
        class RoutingClass(TestRouting):
            def route_call(self, ctx):
                # For the phone call only
                if ctx["to"].uri.user == "555":
                    print("Returning CalleeLeg for 555")
                    #ctx["to"] = Nameaddr(callee_uri)
                    return CalleeLeg(self.call, metapoll)  # TODO: Call has no metapoll yet
            
                # FIXME: is RoutingClass legal here? Not according to pyflakes!
                return super(RoutingClass, self).route_call(ctx)  


    def __init__(self, metapoll, *args):
        super(SwitchB, self).__init__(metapoll, *args)
        
        self.authority.setuser(*callee_cred)
        self.authority.adduser(*caller_cred)

        metapoll.register_timeout(timedelta(seconds=1), WeakMethod(self.test_registering))


    def test_registering(self):
        print("Registering begins.")

        self.registration_manager.start_registration(
        #    a_registrar, callee_uri, callee_uri
            a_registrar, Uri(Addr("A-NET", None), "555"), Uri(b_addr, "555")
        )
    

setup_exchandler()
logging.basicConfig(level=logging.DEBUG)
metapoll = Metapoll()

mgw = MediaGateway(metapoll, mgw_addr)

switch_a = SwitchA(Weak(metapoll), a_addr, mgc1_addr, mgw_addr, range(30000, 30020, 2), "A-NET")
switch_b = SwitchB(Weak(metapoll), b_addr, mgc2_addr, mgw_addr, range(40000, 40020, 2), "B-NET")

#switch_a.transport.set_peer(switch_b.transport)
#switch_b.transport.set_peer(switch_a.transport)

while True:
    try:
        metapoll.do_poll()
    except KeyboardInterrupt:
        raise  #break
