#! /usr/bin/python

from __future__ import print_function, unicode_literals
from datetime import timedelta
import logging
import socket
from async import Metapoll, WeakMethod, Weak

from format import Addr, Uri, Nameaddr, Status, Hop, print_structured_message, parse_structured_message
from transactions import TransactionManager, make_simple_response
from dialog import Dialog, DialogManager
from leg import Leg, SipLeg, create_uninvited_leg
from call import Call
from sdp import Sdp
from authority import Authority
from registrar import RegistrationManager, RecordManager
from util import resolve
from mgw import ContextManager
from mgc import Controller, ProxiedMediaChannel, ProxiedMediaLeg, EchoedMediaLeg, PlayerMediaLeg

HOST = "otthon"
a_addr = Addr(HOST, 5060)
b_addr = Addr(HOST, 5062)

a_registrar = Uri(a_addr)

caller_uri = Uri(a_addr, "caller")
caller_name = "Caller"
caller_nameaddr = Nameaddr(caller_uri, caller_name)

callee_uri = Uri(b_addr, "callee")
callee_name = "Callee"
callee_nameaddr = Nameaddr(callee_uri, callee_name)

#wrong_uri = Uri(local_addr, "wrong")

caller_cred = ("CALLER_AUTHNAME", "CALLER_HA1")
callee_cred = ("CALLEE_AUTHNAME", "CALLEE_HA1")
phone_cred = ("phone", "29947c88227ea55104f09dbdd5e6c48e")  # md5(phone:A-NET:secret)

caller_audio_addr = (HOST, 10000)
caller_video_addr = (HOST, 10001)

caller_sdp = Sdp.parse("""
v=0
o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5
s=SDP Seminar
i=A Seminar on the session description protocol
u=http://www.example.com/seminars/sdp.pdf
e=j.doe@example.com (Jane Doe)
c=IN IP4 224.2.17.12
t=2873397496 2873404696
a=recvonly
m=audio 49170 RTP/AVP 0
m=video 51372 RTP/AVP 99
a=rtpmap:99 h263-1998/90000
""")

MEDIA_HOST = "otthon"
MGW_HOST = "localhost"
MGC1_HOST = "localhost"
MGC2_HOST = "localhost"
mgw_addr = (MGW_HOST, 20000)
mgc1_addr = (MGC1_HOST, 20001)
mgc2_addr = (MGC2_HOST, 20002)


def sleep(secs, method):
    metapoll.register_timeout(timedelta(seconds=secs), WeakMethod(method))


def indented(text, indent="  "):
    return "\n" + "\n".join(indent + line for line in text.split("\n"))


class CalleeLeg(Leg):
    def __init__(self):
        super(CalleeLeg, self).__init__()
        
        self.media_leg = None
        
        
    def do(self, action):
        if action["type"] == "dial":
            self.offer = action.get("offer")
            print("Got offer:\n%s" % repr(self.offer))
            sleep(1, self.ringing)
        elif action["type"] == "hangup":
            print("The caller hung up.")

        
    def ringing(self):
        self.report(dict(type="ring"))
        sleep(1, self.answering)


    def answering(self):
        answer = self.make_answer(self.offer)
        self.report(dict(type="accept", answer=answer))
        sleep(5, self.fading)
        
        
    def fading(self):
        self.media_leg.change(volume=0, fade=5)
        self.report(dict(type="refresh"))
        sleep(5, self.hanging)
        
    
    def hanging(self):
        self.report(dict(type="hangup"))


    def make_answer(self, offer):
        return offer


    def make_media_leg(self, sdp_channel):
        #return EchoedMediaLeg()
        self.media_leg = PlayerMediaLeg(("PCMA", 8000), "playback.wav", volume=0.2, fade=5)
        return self.media_leg
        

class CallerLeg(Leg):
    def dial(self):
        self.ctx["from"] = Nameaddr(caller_uri, caller_name)
        self.ctx["to"] = Nameaddr(callee_uri)
        self.report(dict(type="dial", ctx=self.ctx, offer=caller_sdp))
        #self.sleep(3, self.hanging)


    def do(self, action):
        if action["type"] == "accept":
            print("Accepted with SDP:\n%s" % repr(action.get("answer")))
            #self.sleep(1, self.hanging)

            
    def hanging(self):
        self.leg.do(dict(type="hangup"))


class TestTransport(object):
    def __init__(self, local_addr, reception):
        self.reception = reception
        self.transmission = None
        self.hop = Hop(local_addr=local_addr, remote_addr=None, interface="virt")
        
        
    def set_peer(self, peer):
        self.transmission = WeakMethod(peer.process)
        self.hop = Hop(local_addr=self.hop.local_addr, remote_addr=peer.hop.local_addr, interface=self.hop.interface)
        
        
    def get_hop(self, uri):
        return self.hop
        
        
    def send(self, msg):
        if msg["hop"] != self.hop:
            print("This transport can't send this!")
            return
        
        sip = print_structured_message(msg)
        print("Transport sending by %s:" % (self.hop,))
        print("\n" + "\n".join("  %s" % line for line in sip.split("\n")))
        
        metapoll.register_timeout(timedelta(), self.transmission.rebind(sip))


    def process(self, sip):
        #print("Transport receiving:")
        #print(s)
        msg = parse_structured_message(sip)
        msg["hop"] = self.hop
        self.reception(msg)


class UdpTransport(object):
    def __init__(self, metapoll, local_addr, reception):
        self.metapoll = metapoll
        self.local_addr = local_addr
        self.reception = reception
        
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(self.local_addr)

        self.metapoll.register_reader(self.socket, WeakMethod(self.recved))
        
        
    def get_hop(self, uri):
        return Hop(local_addr=self.local_addr, remote_addr=uri.addr, interface="eth0")
        
        
    def send(self, msg):
        hop = msg["hop"]
        
        if hop.local_addr != self.local_addr:
            print("This transport can't send this!")
            return
        
        sip = print_structured_message(msg)
        print("Transport sending from %s to %s:" % (hop.local_addr, hop.remote_addr))
        print(indented(sip))
        
        self.socket.sendto(sip, hop.remote_addr)


    def recved(self):
        sip, raddr = self.socket.recvfrom(65535)
        hop = Hop(local_addr=self.local_addr, remote_addr=Addr(*raddr), interface="eth0")
        print("Transport receiving from %s to %s:" % (hop.remote_addr, hop.local_addr))
        print(indented(sip))
        
        msg = parse_structured_message(sip)
        msg["hop"] = hop
        self.reception(msg)


class TestAuthority(Authority):
    def __init__(self, realm, record_manager):
        super(TestAuthority, self).__init__(realm)
        
        self.record_manager = record_manager
        self.users = {}
        self.myuser = None
        
        
    def adduser(self, authname, ha1):
        self.users[authname] = ha1
        
        
    def setuser(self, authname, ha1):
        self.myuser = (authname, ha1)
        

    def authenticate(self, params):
        method = params["method"]
        from_uri = params["from"].uri
        hop = params["hop"]
        contact_hops = self.record_manager.lookup_contact_hops(from_uri)
        
        if method != "REGISTER" and hop in contact_hops:
            print("Trusting registered user '%s'" % (from_uri,))
            return True
        
        authname = self.get_digest_authname(params)
        if authname in self.users:
            return self.check_digest_ha1(params, self.users[authname])
            
        return False
            
            
    def identify(self, params):
        return self.myuser


class TestController(Controller):
    next_ctx = 1
    next_port = 30000
    
    def make_media_channel(self, media_legs):
        # Must use unique MGW addresses for Msgp
        key = chr(self.mgc_addr[1] % 10 + 96)
        context_id = "ctx-%s-%d" % (key, self.next_ctx)
        sid = (resolve(mgw_addr), context_id)  # TODO: make Sid class!
        self.next_ctx += 1
        
        # Must use IP4 addresses or FQDN in SDP, so let's go with IP4
        for li, leg in media_legs.items():
            if not leg:
                addr = (MEDIA_HOST, self.next_port)
                self.next_port += 1
                media_legs[li] = ProxiedMediaLeg(resolve(addr))
        
        return ProxiedMediaChannel(Weak(self), sid, media_legs)
        

class Switch(object):
    def __init__(self, metapoll, local_addr, mgc_addr, realm):
        self.metapoll = metapoll
        self.transport = UdpTransport(metapoll, local_addr, WeakMethod(self.reception))
        self.transaction_manager = TransactionManager(local_addr, WeakMethod(self.transport.send))
        self.record_manager = RecordManager(WeakMethod(self.transaction_manager.send_message))
        self.authority = TestAuthority(realm, Weak(self.record_manager))  # TODO: domain2realm!
        self.registration_manager = RegistrationManager(
            WeakMethod(self.transaction_manager.send_message),
            WeakMethod(self.transport.get_hop),
            WeakMethod(self.authority.provide_auth)
        )
        self.dialog_manager = DialogManager(
            local_addr,
            WeakMethod(self.transaction_manager.send_message),
            WeakMethod(self.transport.get_hop),
            WeakMethod(self.authority.provide_auth)
        )
        self.mgc = TestController(metapoll, mgc_addr)

        self.calls = []

        metapoll.register_timeout(timedelta(seconds=0.2), WeakMethod(self.transaction_manager.maintenance), repeat=True)

    
    def reject_request(self, msg, status):
        if msg:
            response = make_simple_response(msg, status)
            self.transaction_manager.send_message(response, msg)


    def challenge_request(self, msg, challenge):
        if msg:
            response = make_simple_response(msg, Status(401, "Hey"), challenge)
            self.transaction_manager.send_message(response, msg)


    def route_to_registered_sip_contact(self, ctx):
        to_uri = ctx["to"].uri
        print("Checking registered SIP contact: %s" % (to_uri,))
        contacts = self.record_manager.lookup_contact_uris(to_uri)
            
        if contacts:
            ctx["to"] = Nameaddr(contacts[0])
            outgoing_dialog = Dialog(Weak(self.dialog_manager))
            outgoing_leg = SipLeg(outgoing_dialog)
            return outgoing_leg
        else:
            print("No such registered SIP contact: %s" % (to_uri,))
            return None
        
        
    def start_call(self, incoming_leg):
        call = Call(Weak(self.mgc), WeakMethod(self.route_call), WeakMethod(self.finish_call))
        call.add_leg(0, incoming_leg)
        self.calls.append(call)
    

    def route_call(self, ctx):
        return self.route_to_registered_sip_contact(ctx)
        
        
    def finish_call(self, call):
        # TODO: Call should be smarter!
        
        def ugly_delayed_finish():
            print("Finishing call")
            self.calls.remove(call)
            
        self.metapoll.register_timeout(timedelta(seconds=1), ugly_delayed_finish)
        

    def accept_invite(self, params):
        incoming_dialog = Dialog(Weak(self.dialog_manager))
        incoming_leg = SipLeg(incoming_dialog)
        self.start_call(incoming_leg)
        
        return WeakMethod(incoming_dialog.recv_request)


    def process_request(self, params):
        if params["uri"].schema != "sip":
            WeakMethod(self.reject_request, Status(404, "Not found"))
            
        challenge = self.authority.require_auth(params)
        if challenge:
            return WeakMethod(self.challenge_request, challenge)

        if params["method"] == "REGISTER":
            return self.record_manager.match_incoming_request(params)

        report = self.dialog_manager.match_incoming_request(params)
        if report:
            return report
    
        if params["method"] == "INVITE" and "tag" not in params["to"].params:
            return self.accept_invite(params)
    
        return WeakMethod(self.reject_request, Status(400, "Bad request"))
        

    def reception(self, params):
        #print("Got message from transport.")
        #print("Req params: %s" % req_params)
        uninvite_params = self.transaction_manager.match_uninvited_response(params)
        if uninvite_params:
            create_uninvited_leg(uninvite_params)
    
        if self.transaction_manager.match_incoming_message(params):
            return

        report = self.process_request(params)
        
        self.transaction_manager.create_incoming_request(params, report)


class SwitchA(Switch):
    def __init__(self, metapoll, *args):
        super(SwitchA, self).__init__(metapoll, *args)
        
        self.authority.setuser(*caller_cred)
        self.authority.adduser(*callee_cred)
        self.authority.adduser(*phone_cred)

        #metapoll.register_timeout(timedelta(seconds=2), WeakMethod(self.test_dialing))
        
        
    def route_call(self, ctx):
        # For the phone call only
        if ctx["to"].uri.user == "555":
            #ctx["to"] = Nameaddr(callee_uri)
            return CalleeLeg()
            
        return super(SwitchA, self).route_call(ctx)
            
        
    def test_dialing(self):
        print("Dialing begins.")

        incoming_leg = CallerLeg()
        self.start_call(incoming_leg)
        
        incoming_leg.dial()
    

class SwitchB(Switch):
    def __init__(self, metapoll, *args):
        super(SwitchB, self).__init__(metapoll, *args)
        
        self.authority.setuser(*callee_cred)
        self.authority.adduser(*caller_cred)

        #metapoll.register_timeout(timedelta(seconds=1), WeakMethod(self.test_registering))


    def route_call(self, ctx):
        to_uri = ctx["to"].uri
        
        if to_uri.user == "callee":
            return CalleeLeg()
            
        return super(SwitchB, self).route_call(ctx)
        
        
    def test_registering(self):
        print("Registering begins.")

        self.registration_manager.start_registration(a_registrar, callee_uri, callee_uri)
    

logging.basicConfig(level=logging.DEBUG)
metapoll = Metapoll()

mgw = ContextManager(metapoll, mgw_addr)

switch_a = SwitchA(Weak(metapoll), a_addr, mgc1_addr, "A-NET")
switch_b = SwitchB(Weak(metapoll), b_addr, mgc2_addr, "B-NET")

#switch_a.transport.set_peer(switch_b.transport)
#switch_b.transport.set_peer(switch_a.transport)

while True:
    try:
        metapoll.do_poll()
    except KeyboardInterrupt:
        raise  #break
