#! /usr/bin/python3

from __future__ import print_function, unicode_literals
from datetime import timedelta
import logging
import logging.config
from async import Metapoll, WeakMethod, Weak

from format import Addr, Uri, Nameaddr, Status
from transport import UdpTransport
from transactions import TransactionManager, make_simple_response
from dialog import Dialog, DialogManager
from leg import SipLeg, PlannedLeg, create_uninvited_leg
from call import Call, SimpleRouting, PlannedRouting
from sdp import Sdp
from authority import Authority
from registrar import RegistrationManager, RecordManager
from account import Account, AccountManager
from util import resolve, setup_exchandler, build_oid, Logger
from mgw import MediaGateway
from mgc import Controller, PlayerMediaLeg

HOST = "otthon"
A_ADDR = Addr(HOST, 5060)
B_ADDR = Addr(HOST, 5062)

A_DOMAIN = "a.switch"
B_DOMAIN = "b.switch"

#caller_uri = Uri(, "caller")
#caller_name = "Caller"
CALLER_NAMEADDR = Nameaddr(Uri(Addr(A_DOMAIN, None), "caller"), "Caller")

#callee_uri = Uri(b_addr, "callee")
#callee_name = "Callee"
#callee_nameaddr = Nameaddr(callee_uri, callee_name)
CALLEE_NAMEADDR = Nameaddr(Uri(Addr(B_DOMAIN, None), "callee"), "Callee")

#wrong_uri = Uri(local_addr, "wrong")

#CALLER_CRED = ("CALLER_AUTHNAME", "CALLER_HA1")
#CALLEE_CRED = ("CALLEE_AUTHNAME", "CALLEE_HA1")
A_CRED = ("A_AUTHNAME", "A_HA1")
B_CRED = ("B_AUTHNAME", "B_HA1")

PHONE_CALLERID = "phone"
PHONE_NUMBER = "555"
#phone_cred = ("phone", "29947c88227ea55104f09dbdd5e6c48e")  # md5(phone:A-NET:secret)
PHONE_CRED = ("phone", "38450ead4036feb352c45462d8008511")  # md5(phone:a.switch:secret)

CALLER_SDP = Sdp.parse("""
v=0
o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5
s=SDP Seminar
i=A Seminar on the session description protocol
u=http://www.example.com/seminars/sdp.pdf
e=j.doe@example.com (Jane Doe)
c=IN IP4 224.2.17.12
t=2873397496 2873404696
a=recvonly
m=audio 49170 RTP/AVP 0
m=video 51372 RTP/AVP 99
a=rtpmap:99 h263-1998/90000
""")

MGW_HOST = "localhost"
MGC1_HOST = "localhost"
MGC2_HOST = "localhost"
MGW_ADDR = Addr(MGW_HOST, 20000)
MGC1_ADDR = Addr(MGC1_HOST, 20001)
MGC2_ADDR = Addr(MGC2_HOST, 20002)

MEDIA_HOST = "otthon"

#logger = logging.getLogger()


class UnreachableLeg(PlannedLeg):
    def plan(self, planner):
        self.logger.debug("Unreachable leg created.")
        
        yield from planner.wait_action("dial")
        self.logger.debug("Got dial, but not answering anything.")

        yield from planner.wait_action("hangup")
        self.logger.debug("And now the caller hung up.")


class RejectingLeg(PlannedLeg):
    def plan(self, planner):
        self.logger.debug("Rejecting leg created.")
        
        yield from planner.wait_action("dial")
        self.logger.debug("Got dial, but not now rejecting it.")

        self.report(dict(type="reject", status=Status(603)))

        self.logger.debug("And now done.")


class CalleeLeg(PlannedLeg):
    def plan(self, planner):
        self.logger.debug("Callee created.")
        
        action = yield from planner.wait_action("dial")
        self.offer = action.get("offer")
        self.logger.debug("Got offer:\n%s" % repr(self.offer))
        
        yield from planner.sleep(1)
        self.report(dict(type="ring"))
        
        yield from planner.sleep(1)
        answer = self.make_answer(self.offer)
        sid = self.call.select_gateway_sid(0)
        media_leg = PlayerMediaLeg(self.call.switch.mgc, sid)
        media_leg.set_oid(build_oid(self.oid, "media", len(self.media_legs)))
        self.media_legs.append(media_leg)
        self.report(dict(type="accept", answer=answer))
        # It shouldn't be legal to answer without channels existing already!
        self.media_legs[0].play("playback.wav", ("PCMA", 8000), volume=0.2, fade=3)
        #self.refresh_media()
        
        yield from planner.sleep(3)
        self.media_legs[0].play(volume=0, fade=3)
        #self.refresh_media()
        
        yield from planner.sleep(3)
        self.report(dict(type="hangup"))

        self.logger.debug("Callee done.")
        

    def make_answer(self, offer):
        return offer


class CallerLeg(PlannedLeg):
    def plan(self, planner):
        self.logger.debug("Caller created")
        
        yield from planner.sleep(0)
        self.ctx["from"] = CALLER_NAMEADDR
        self.ctx["to"] = Nameaddr(CALLEE_NAMEADDR.uri)
        self.report(dict(type="dial", ctx=self.ctx, offer=CALLER_SDP))

        action = yield from planner.wait_action("accept")
        self.logger.debug("Accepted with SDP:\n%s" % repr(action.get("answer")))

        action = yield from planner.expect("action")
        assert action["type"] == "hangup"
        
        self.logger.debug("Caller done.")
        #yield from planner.sleep(3)
        #self.leg.do(dict(type="hangup"))


class TestRecordManager(RecordManager):
    pass
        

class TestAuthority(Authority):
    pass


class TestController(Controller):
    def __init__(self, metapoll, mgw_addr, ports):
        super().__init__(metapoll, mgw_addr)
        
        #self.mgw_addr = resolve(mgw_addr)
        
        # Must use IP4 addresses or FQDN in SDP, so let's go with IP4
        # Media host may be different from the signaling host
        self.media_addresses = set(resolve(Addr(MEDIA_HOST, port)) for port in ports)
        
    
    def allocate_media_addr(self, sid):
        return self.media_addresses.pop()
    
    
    def deallocate_media_addr(self, sid, addr):
        self.media_addresses.add(addr)
        
        
class TestRouting(SimpleRouting):
    def route_ctx(self, ctx):
        to_uri = ctx["to"].uri
        self.logger.debug("Checking registered SIP contact: %s" % (to_uri,))
        contacts = self.call.switch.record_manager.lookup_contacts(to_uri)
            
        if len(contacts) == 1:
            uri, hop = contacts[0]
            ctx["uri"] = uri  # Only update the RURI for forwarding
            ctx["hop"] = hop
        else:
            self.logger.debug("Not one registered SIP contact: %s" % (to_uri,))
            raise Exception("Routing failed!")


class TestCall(Call):
    RoutingClass = TestRouting
    
    
    def make_routing(self):
        return self.RoutingClass(Weak(self))
    

class Switch(object):
    CallClass = TestCall
    
    def __init__(self, metapoll, local_addr, mgc_addr, mgw_addr, media_ports):
        self.metapoll = metapoll
        self.transport = UdpTransport(metapoll, local_addr, WeakMethod(self.reception))
        self.transaction_manager = TransactionManager(local_addr, WeakMethod(self.transport.send))
        self.record_manager = TestRecordManager(WeakMethod(self.transaction_manager.send_message))
        self.authority = TestAuthority()
        self.registration_manager = RegistrationManager(
            WeakMethod(self.transaction_manager.send_message),
            WeakMethod(self.transport.get_hop),
            WeakMethod(self.authing)
        )
        self.dialog_manager = DialogManager(
            local_addr,
            WeakMethod(self.transaction_manager.send_message),
            WeakMethod(self.transport.get_hop),
            WeakMethod(self.authing)
        )
        self.mgc = TestController(metapoll, mgw_addr, media_ports)
        self.account_manager = AccountManager()

        self.calls_by_oid = {}
        self.call_count = 0
        
        self.logger = Logger()

        metapoll.register_timeout(timedelta(seconds=0.2), WeakMethod(self.transaction_manager.maintenance), repeat=True)


    def set_oid(self, oid):
        self.oid = oid
        self.logger.set_oid(oid)

        self.account_manager.set_oid(build_oid(oid, "accman"))
        self.authority.set_oid(build_oid(oid, "authority"))
        self.record_manager.set_oid(build_oid(oid, "recman"))
        self.registration_manager.set_oid(build_oid(oid, "regman"))
        self.transport.set_oid(build_oid(oid, "transport"))
        self.dialog_manager.set_oid(build_oid(oid, "diaman"))
        self.mgc.set_oid(build_oid(oid, "mgc"))


    def authing(self, response, request):
        creds = self.account_manager.get_our_credentials()
        return self.authority.provide_auth(response, request, creds)
        
    
    def reject_request(self, msg, status):
        if msg:
            response = make_simple_response(msg, status)
            self.transaction_manager.send_message(response, msg)


    def challenge_request(self, msg, challenge):
        if msg:
            response = make_simple_response(msg, Status(401, "Hey"), challenge)
            self.transaction_manager.send_message(response, msg)


    def make_outgoing_leg(self, uri):
        if uri.scheme == "sip":
            outgoing_dialog = Dialog(Weak(self.dialog_manager))
            outgoing_leg = SipLeg(outgoing_dialog)
            return outgoing_leg
        elif uri.scheme == "builtin":
            if uri.addr.host == "callee":
                return CalleeLeg(self.metapoll)
            else:
                raise Exception("Unknown builtin URI '%s'!" % uri.addr.host)
        else:
            raise Exception("Unknown URI scheme '%s'!" % uri.scheme)


    def make_call(self):
        return self.CallClass(Weak(self))
        
        
    def start_call(self, params):  # TODO: params unused
        call = self.make_call()
        
        oid = build_oid(self.oid, "call", self.call_count)
        self.call_count += 1
        call.set_oid(oid)
        
        self.calls_by_oid[oid] = call

        incoming_dialog = Dialog(Weak(self.dialog_manager))
        incoming_leg = SipLeg(incoming_dialog)
        
        call.start_routing(incoming_leg)
        return WeakMethod(incoming_dialog.recv_request)
    

    def finish_call(self, oid):
        # TODO: Call should be smarter! Hm, are we now?
        
        def ugly_delayed_finish():
            self.logger.debug("Finishing call")
            self.calls_by_oid.pop(oid)
            
        self.metapoll.register_timeout(timedelta(seconds=1), ugly_delayed_finish)
        

    def process_request(self, params):
        method = params["method"]
        request_uri = params["uri"]
        from_uri = params["from"].uri
        #to_uri = params["to"].uri
        hop = params["hop"]
        
        if request_uri.scheme != "sip":  # TODO: add some addr checks, too
            return WeakMethod(self.reject_request, Status(404, "Not found"))

        auth_policy = self.account_manager.get_account_auth_policy(from_uri)
        must_auth = None
        
        if method in ("CANCEL", "ACK"):
            must_auth = False
            self.logger.debug("Accepting request because it can't be authenticated anyway")
        elif not auth_policy:
            self.logger.debug("Rejecting request because account is unknown")
            return WeakMethod(self.reject_request, Status(403, "Forbidden"))
        elif auth_policy == Account.AUTH_NEVER:
            must_auth = False
            self.logger.debug("Accepting request because authentication is never needed")
        elif auth_policy == Account.AUTH_ALWAYS:
            must_auth = True
            self.logger.debug("Challenging request because authentication is always needed")
        elif auth_policy == Account.AUTH_IF_UNREGISTERED:
            must_auth = (hop not in self.record_manager.lookup_contact_hops(from_uri))
            if must_auth:
                self.logger.debug("Challenging request because account is not registered")
            else:
                self.logger.debug("Accepting request because account is registered")
        elif auth_policy == Account.AUTH_BY_ADDRESS:
            if hop not in self.record_manager.lookup_contact_hops(from_uri):
                self.logger.debug("Rejecting request because hop address is not allowed")
                return WeakMethod(self.reject_request, Status(403, "Forbidden"))
            else:
                must_auth = False
                self.logger.debug("Accepting request because hop address is allowed")
        else:
            raise Exception("WTF?")

        if must_auth:
            creds = self.account_manager.get_account_credentials(from_uri)
            challenge = self.authority.require_auth(params, creds)
            
            if challenge:
                self.logger.debug("Rejecting request without proper authentication")
                return WeakMethod(self.challenge_request, challenge)
            else:
                self.logger.debug("Accepting request with proper authentication")

        if method == "REGISTER":
            # If the From URI was OK, then the To URI is as well, because
            # we don't support third party registrations now.
            return self.record_manager.match_incoming_request(params)

        report = self.dialog_manager.match_incoming_request(params)
        if report:
            return report
    
        if method == "INVITE" and "tag" not in params["to"].params:
            return self.start_call(params)
    
        return WeakMethod(self.reject_request, Status(400, "Bad request"))
        

    def reception(self, params):
        #print("Got message from transport.")
        #print("Req params: %s" % req_params)
        uninvite_params = self.transaction_manager.match_uninvited_response(params)
        if uninvite_params:
            create_uninvited_leg(uninvite_params)
    
        if self.transaction_manager.match_incoming_message(params):
            return

        report = self.process_request(params)
        
        self.transaction_manager.create_incoming_request(params, report)


class SwitchA(Switch):
    def __init__(self, metapoll, *args):
        super(SwitchA, self).__init__(metapoll, *args)
        
        player_uri = Uri(Addr(A_DOMAIN, None), PHONE_NUMBER)
        phone_uri = Uri(Addr(A_DOMAIN, None), PHONE_CALLERID)
        
        self.account_manager.add_account(player_uri, "Playa", Account.AUTH_IF_UNREGISTERED, B_CRED[0], B_CRED[1])
        self.account_manager.add_account(phone_uri, "Phone", Account.AUTH_IF_UNREGISTERED, PHONE_CRED[0], PHONE_CRED[1])

        self.account_manager.set_our_credentials(*A_CRED)
        
        #metapoll.register_timeout(timedelta(seconds=2), WeakMethod(self.test_dialing))
        
        
    def test_dialing(self):
        self.logger.debug("Dialing begins.")

        #incoming_leg = CallerLeg()
        #self.start_call(incoming_leg)
        
        #incoming_leg.dial()
    

class SwitchB(Switch):
    class CallClass(TestCall):
        class RoutingClass(PlannedRouting):
            def plan(self, planner, action):
                self.logger.debug("Routing plan started.")
                self.dial(dict(action, ctx=dict(action["ctx"], uri=Uri.parse("builtin:callee"))))
                li, action = yield from planner.wait_leg_action()
                self.forward(li, action)
                
                
        class XRoutingClass(TestRouting):
            def route_ctx(self, ctx):
                # For the phone call only
                if ctx["to"].uri.user == PHONE_NUMBER:
                    self.logger.debug("Routing to CalleeLeg for %s" % PHONE_NUMBER)
                    ctx["uri"] = Uri.parse("builtin:callee")
                    #return CalleeLeg(self.call, self.switch.metapoll)
                    #self.logger.debug("Returning UnreachableLeg for %s" % PHONE_NUMBER)
                    #return UnreachableLeg(self.call, self.switch.metapoll)
                    #self.logger.debug("Returning RejectingLeg for %s" % PHONE_NUMBER)
                    #return RejectingLeg(self.call, self.switch.metapoll)
                else:
                    TestRouting.route_call(self, ctx)


    def __init__(self, metapoll, *args):
        super(SwitchB, self).__init__(metapoll, *args)
        
        phone_uri = Uri(Addr(A_DOMAIN, None), PHONE_CALLERID)
        
        self.account_manager.add_account(phone_uri, "Phone", Account.AUTH_IF_UNREGISTERED, A_CRED[0], A_CRED[1])
        
        self.account_manager.set_our_credentials(*B_CRED)

        metapoll.register_timeout(timedelta(seconds=1), WeakMethod(self.test_registering))


    def test_registering(self):
        self.logger.debug("Registering begins.")

        self.registration_manager.start_registration(
        #    a_registrar, callee_uri, callee_uri
            registrar_uri=Uri(A_ADDR),
            record_uri=Uri(Addr(A_DOMAIN, None), PHONE_NUMBER),
            contact_uri=Uri(B_ADDR, PHONE_NUMBER)
        )


def main():
    # By using only local variables, they'll be released when exiting this function,
    # so various __del__ methods will run before interpreter shutdown, when even
    # logging is disfunctional.
    
    setup_exchandler()
    
    class OidLogFilter(logging.Filter):
        def filter(self, record):
            if not hasattr(record, 'oid'):
                record.oid = record.name
            
            #if "/" in record.oid:
                #record.oid = ".".join(
                #    x[:1] if not x.isdigit() else x for x in record.oid.split(".")
                #)
            #    record.oid = "/".join(
            #        "%s=%s" % (k[:1], v) for k, v in (x.split("=") for x in record.oid.split("/"))
            #    )
            
            return True
    
    logging.config.dictConfig({
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'default': {
                #'format': '%(asctime)s.%(msecs)03d  %(name)s  %(levelname)s  %(message)s',
                #'format': '%(name)-10s | %(message)s',
                'format': '%(oid)s | %(message)s',
                'datefmt': '%F %T'
            }
        },
        'filters': {
            'oidfilter': {
                '()': OidLogFilter
            }
        },
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'formatter': 'default',
                'filters': [ 'oidfilter' ]
            },
            'file': {
                'class': 'logging.FileHandler',
                'formatter': 'default',
                'filters': [ 'oidfilter' ],
                'filename': 'siplibtest.log',
                'mode': 'w'
            }
        },
        'loggers': {
            '': {
                'level': logging.DEBUG,
                'handlers': [ 'console', 'file' ]
            },
            'msgp': {
                'level': logging.INFO
            }
        }
    })
    
    logging.debug("Hello!")

    metapoll = Metapoll()

    mgw = MediaGateway(metapoll, MGW_ADDR)
    mgw.set_oid("mgw")

    switch_a = SwitchA(Weak(metapoll), A_ADDR, MGC1_ADDR, MGW_ADDR, range(30000, 30020, 2))
    switch_a.set_oid(build_oid(None, "switch", "a"))
    
    switch_b = SwitchB(Weak(metapoll), B_ADDR, MGC2_ADDR, MGW_ADDR, range(40000, 40020, 2))
    switch_b.set_oid(build_oid(None, "switch", "b"))

    #switch_a.transport.set_peer(switch_b.transport)
    #switch_b.transport.set_peer(switch_a.transport)

    while True:
        try:
            metapoll.do_poll()
        except KeyboardInterrupt:
            #raise
            break

    del switch_b
    del switch_a
    del mgw
    del metapoll
    
    logging.debug("Bye!")


main()
