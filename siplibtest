#! /usr/bin/python3

from __future__ import print_function, unicode_literals
from datetime import timedelta
import logging
import logging.config
from async import Metapoll, WeakMethod, Weak

from format import Addr, Uri, Nameaddr, Status
from transport import UdpTransport
from transactions import TransactionManager, make_simple_response
from dialog import Dialog, DialogManager
from leg import SipLeg, PlannedLeg, create_uninvited_leg
from call import Call, Routing
from sdp import Sdp
from authority import Authority
from registrar import RegistrationManager, RecordManager
from account import Account, AccountManager
from util import resolve, setup_exchandler
from mgw import MediaGateway
from mgc import Controller, PlayerMediaLeg

HOST = "otthon"
A_ADDR = Addr(HOST, 5060)
B_ADDR = Addr(HOST, 5062)

A_DOMAIN = "a.switch"
B_DOMAIN = "b.switch"

#caller_uri = Uri(, "caller")
#caller_name = "Caller"
CALLER_NAMEADDR = Nameaddr(Uri(Addr(A_DOMAIN, None), "caller"), "Caller")

#callee_uri = Uri(b_addr, "callee")
#callee_name = "Callee"
#callee_nameaddr = Nameaddr(callee_uri, callee_name)
CALLEE_NAMEADDR = Nameaddr(Uri(Addr(B_DOMAIN, None), "callee"), "Callee")

#wrong_uri = Uri(local_addr, "wrong")

#CALLER_CRED = ("CALLER_AUTHNAME", "CALLER_HA1")
#CALLEE_CRED = ("CALLEE_AUTHNAME", "CALLEE_HA1")
A_CRED = ("A_AUTHNAME", "A_HA1")
B_CRED = ("B_AUTHNAME", "B_HA1")

PHONE_CALLERID = "phone"
PHONE_NUMBER = "555"
#phone_cred = ("phone", "29947c88227ea55104f09dbdd5e6c48e")  # md5(phone:A-NET:secret)
PHONE_CRED = ("phone", "38450ead4036feb352c45462d8008511")  # md5(phone:a.switch:secret)

CALLER_SDP = Sdp.parse("""
v=0
o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5
s=SDP Seminar
i=A Seminar on the session description protocol
u=http://www.example.com/seminars/sdp.pdf
e=j.doe@example.com (Jane Doe)
c=IN IP4 224.2.17.12
t=2873397496 2873404696
a=recvonly
m=audio 49170 RTP/AVP 0
m=video 51372 RTP/AVP 99
a=rtpmap:99 h263-1998/90000
""")

MGW_HOST = "localhost"
MGC1_HOST = "localhost"
MGC2_HOST = "localhost"
MGW_ADDR = Addr(MGW_HOST, 20000)
MGC1_ADDR = Addr(MGC1_HOST, 20001)
MGC2_ADDR = Addr(MGC2_HOST, 20002)

MEDIA_HOST = "otthon"

logger = logging.getLogger()


def sleep(secs, method):
    metapoll.register_timeout(timedelta(seconds=secs), WeakMethod(method))


class CalleeLeg(PlannedLeg):
    def plan(self, planner):
        logger.debug("Callee created.")
        
        action = yield from planner.wait_action("dial")
        self.offer = action.get("offer")
        logger.debug("Got offer:\n%s" % repr(self.offer))
        
        yield from planner.sleep(1)
        self.report(dict(type="ring"))
        
        yield from planner.sleep(1)
        answer = self.make_answer(self.offer)
        self.report(dict(type="accept", answer=answer))
        self.media_legs.append(PlayerMediaLeg(self.call.mgc))
        self.media_legs[0].play("playback.wav", ("PCMA", 8000), volume=0.2, fade=3)
        self.refresh_media()
        
        yield from planner.sleep(3)
        self.media_legs[0].play(volume=0, fade=3)
        self.refresh_media()
        
        yield from planner.sleep(3)
        self.report(dict(type="hangup"))

        logger.debug("Callee done.")
        

    def make_answer(self, offer):
        return offer


class UnreachableLeg(PlannedLeg):
    def plan(self, planner):
        logger.debug("Unreachable leg created.")
        
        yield from planner.suspend(expect="judgement-day")
        
        logger.error("Unreachable leg woke up from the dead!")
        
        

class CallerLeg(PlannedLeg):
    def plan(self, planner):
        logger.debug("Caller created")
        
        yield from planner.sleep(0)
        self.ctx["from"] = CALLER_NAMEADDR
        self.ctx["to"] = Nameaddr(CALLEE_NAMEADDR.uri)
        self.report(dict(type="dial", ctx=self.ctx, offer=CALLER_SDP))

        action = yield from planner.wait_action("accept")
        logger.debug("Accepted with SDP:\n%s" % repr(action.get("answer")))

        action = yield from planner.expect("action")
        assert action["type"] == "hangup"
        
        logger.debug("Caller done.")
        #yield from planner.sleep(3)
        #self.leg.do(dict(type="hangup"))


class TestRecordManager(RecordManager):
    pass
        

class TestAuthority(Authority):
    pass


class TestController(Controller):
    def __init__(self, metapoll, mgc_addr, mgw_addr, ports):
        super().__init__(metapoll, mgc_addr)
        
        self.mgw_addr = resolve(mgw_addr)
        
        # Must use IP4 addresses or FQDN in SDP, so let's go with IP4
        # Media host may be different from the signaling host
        self.media_addresses = set(resolve(Addr(MEDIA_HOST, port)) for port in ports)
        
    
    def allocate_media_address(self, channel_index):
        return self.media_addresses.pop()
    
    
    def deallocate_media_address(self, addr):
        self.media_addresses.add(addr)
        
        
    def select_gateway_address(self, affinity=None):
        return self.mgw_addr
        
    
class TestRouting(Routing):
    def __init__(self, switch, call, report, incoming_leg):
        super(TestRouting, self).__init__(call, report, incoming_leg)
        self.switch = switch
        

    def route_call(self, ctx):
        to_uri = ctx["to"].uri
        logger.debug("Checking registered SIP contact: %s" % (to_uri,))
        contacts = self.switch.record_manager.lookup_contact_uris(to_uri)
            
        if len(contacts) == 1:
            contact_uri = contacts[0]
            ctx["uri"] = contact_uri  # Only update the RURI for forwarding
            #ctx["from"] = ctx["to"]
            #ctx["to"] = Nameaddr(contact_uri)
            outgoing_dialog = Dialog(Weak(self.switch.dialog_manager))
            outgoing_leg = SipLeg(self.call, outgoing_dialog)
            return outgoing_leg
        else:
            logger.debug("Not one registered SIP contact: %s" % (to_uri,))
            raise Exception("Routing failed!")


class TestCall(Call):
    RoutingClass = TestRouting
    
    def __init__(self, switch, mgc, finish_handler):
        super(TestCall, self).__init__(mgc, finish_handler)
        self.switch = switch


    def make_routing(self, incoming_leg):
        return self.RoutingClass(self.switch, Weak(self), WeakMethod(self.routed), incoming_leg)
    

class Switch(object):
    CallClass = TestCall
    
    def __init__(self, metapoll, local_addr, mgc_addr, mgw_addr, media_ports):
        self.metapoll = metapoll
        self.transport = UdpTransport(metapoll, local_addr, WeakMethod(self.reception))
        self.transaction_manager = TransactionManager(local_addr, WeakMethod(self.transport.send))
        self.record_manager = TestRecordManager(WeakMethod(self.transaction_manager.send_message))
        self.authority = TestAuthority()
        self.registration_manager = RegistrationManager(
            WeakMethod(self.transaction_manager.send_message),
            WeakMethod(self.transport.get_hop),
            WeakMethod(self.authing)
        )
        self.dialog_manager = DialogManager(
            local_addr,
            WeakMethod(self.transaction_manager.send_message),
            WeakMethod(self.transport.get_hop),
            WeakMethod(self.authing)
        )
        self.mgc = TestController(metapoll, mgc_addr, mgw_addr, media_ports)
        self.account_manager = AccountManager()

        self.calls = []  # TODO: make it a dict with call identifiers!

        metapoll.register_timeout(timedelta(seconds=0.2), WeakMethod(self.transaction_manager.maintenance), repeat=True)


    def authing(self, response, request):
        creds = self.account_manager.get_our_credentials()
        return self.authority.provide_auth(response, request, creds)
        
    
    def reject_request(self, msg, status):
        if msg:
            response = make_simple_response(msg, status)
            self.transaction_manager.send_message(response, msg)


    def challenge_request(self, msg, challenge):
        if msg:
            response = make_simple_response(msg, Status(401, "Hey"), challenge)
            self.transaction_manager.send_message(response, msg)


    def make_call(self):
        return self.CallClass(Weak(self), Weak(self.mgc), WeakMethod(self.finish_call))
        
        
    def start_call(self, params):  # TODO: params unused
        call = self.make_call()
        self.calls.append(call)

        incoming_dialog = Dialog(Weak(self.dialog_manager))
        incoming_leg = SipLeg(call, incoming_dialog)
        
        call.start_routing(incoming_leg)
        return WeakMethod(incoming_dialog.recv_request)
    

    def finish_call(self, call):
        # TODO: Call should be smarter!
        
        def ugly_delayed_finish():
            logger.debug("Finishing call")
            self.calls.remove(call)
            
        self.metapoll.register_timeout(timedelta(seconds=1), ugly_delayed_finish)
        

    def process_request(self, params):
        method = params["method"]
        request_uri = params["uri"]
        from_uri = params["from"].uri
        #to_uri = params["to"].uri
        hop = params["hop"]
        
        if request_uri.schema != "sip":  # TODO: add some addr checks, too
            return WeakMethod(self.reject_request, Status(404, "Not found"))

        auth_policy = self.account_manager.get_account_auth_policy(from_uri)
        must_auth = None
        
        if method in ("CANCEL", "ACK"):
            must_auth = False
            logger.debug("Accepting request because it can't be authenticated anyway")
        elif not auth_policy:
            logger.debug("Rejecting request because account is unknown")
            return WeakMethod(self.reject_request, Status(403, "Forbidden"))
        elif auth_policy == Account.AUTH_NEVER:
            must_auth = False
            logger.debug("Accepting request because authentication is never needed")
        elif auth_policy == Account.AUTH_ALWAYS:
            must_auth = True
            logger.debug("Challenging request because authentication is always needed")
        elif auth_policy == Account.AUTH_IF_UNREGISTERED:
            must_auth = (hop not in self.record_manager.lookup_contact_hops(from_uri))
            if must_auth:
                logger.debug("Challenging request because account is not registered")
            else:
                logger.debug("Accepting request because account is registered")
        elif auth_policy == Account.AUTH_BY_ADDRESS:
            if hop not in self.record_manager.lookup_contact_hops(from_uri):
                logger.debug("Rejecting request because hop address is not allowed")
                return WeakMethod(self.reject_request, Status(403, "Forbidden"))
            else:
                must_auth = False
                logger.debug("Accepting request because hop address is allowed")
        else:
            raise Exception("WTF?")

        if must_auth:
            creds = self.account_manager.get_account_credentials(from_uri)
            challenge = self.authority.require_auth(params, creds)
            
            if challenge:
                logger.debug("Rejecting request without proper authentication")
                return WeakMethod(self.challenge_request, challenge)
            else:
                logger.debug("Accepting request with proper authentication")

        if method == "REGISTER":
            # If the From URI was OK, then the To URI is as well, because
            # we don't support third party registrations now.
            return self.record_manager.match_incoming_request(params)

        report = self.dialog_manager.match_incoming_request(params)
        if report:
            return report
    
        if method == "INVITE" and "tag" not in params["to"].params:
            return self.start_call(params)
    
        return WeakMethod(self.reject_request, Status(400, "Bad request"))
        

    def reception(self, params):
        #print("Got message from transport.")
        #print("Req params: %s" % req_params)
        uninvite_params = self.transaction_manager.match_uninvited_response(params)
        if uninvite_params:
            create_uninvited_leg(uninvite_params)
    
        if self.transaction_manager.match_incoming_message(params):
            return

        report = self.process_request(params)
        
        self.transaction_manager.create_incoming_request(params, report)


class SwitchA(Switch):
    def __init__(self, metapoll, *args):
        super(SwitchA, self).__init__(metapoll, *args)
        
        player_uri = Uri(Addr(A_DOMAIN, None), PHONE_NUMBER)
        phone_uri = Uri(Addr(A_DOMAIN, None), PHONE_CALLERID)
        
        self.account_manager.add_account(player_uri, "Playa", Account.AUTH_IF_UNREGISTERED, B_CRED[0], B_CRED[1])
        self.account_manager.add_account(phone_uri, "Phone", Account.AUTH_IF_UNREGISTERED, PHONE_CRED[0], PHONE_CRED[1])

        self.account_manager.set_our_credentials(*A_CRED)
        
        #metapoll.register_timeout(timedelta(seconds=2), WeakMethod(self.test_dialing))
        
        
    def test_dialing(self):
        logger.debug("Dialing begins.")

        #incoming_leg = CallerLeg()
        #self.start_call(incoming_leg)
        
        #incoming_leg.dial()
    

class SwitchB(Switch):
    class CallClass(TestCall):
        class RoutingClass(TestRouting):
            def route_call(self, ctx):
                # For the phone call only
                if ctx["to"].uri.user == PHONE_NUMBER:
                    logger.debug("Returning CalleeLeg for %s" % PHONE_NUMBER)
                    #ctx["to"] = Nameaddr(callee_uri)
                    return CalleeLeg(self.call, metapoll)  # TODO: Call has no metapoll yet
            
                # FIXME: is RoutingClass legal here? Not according to pyflakes!
                return super(RoutingClass, self).route_call(ctx)  


    def __init__(self, metapoll, *args):
        super(SwitchB, self).__init__(metapoll, *args)
        
        phone_uri = Uri(Addr(A_DOMAIN, None), PHONE_CALLERID)
        
        self.account_manager.add_account(phone_uri, "Phone", Account.AUTH_IF_UNREGISTERED, A_CRED[0], A_CRED[1])
        
        self.account_manager.set_our_credentials(*B_CRED)

        metapoll.register_timeout(timedelta(seconds=1), WeakMethod(self.test_registering))


    def test_registering(self):
        logger.debug("Registering begins.")

        self.registration_manager.start_registration(
        #    a_registrar, callee_uri, callee_uri
            registrar_uri=Uri(A_ADDR),
            record_uri=Uri(Addr(A_DOMAIN, None), PHONE_NUMBER),
            contact_uri=Uri(B_ADDR, PHONE_NUMBER)
        )
    

setup_exchandler()
logging.config.dictConfig({
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'default': {
            #'format': '%(asctime)s.%(msecs)03d  %(name)s  %(levelname)s  %(message)s',
            'format': '%(name)-10s | %(message)s',
            'datefmt': '%F %T'
        }
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'default'
        },
        'file': {
            'class': 'logging.FileHandler',
            'formatter': 'default',
            'filename': 'siplibtest.log',
            'mode': 'w'
        }
    },
    'loggers': {
        '': {
            'level': logging.DEBUG,
            'handlers': [ 'console', 'file' ]
        },
        'msgp': {
            'level': logging.INFO
        }
    }
})
logging.debug("Hello!")
metapoll = Metapoll()

mgw = MediaGateway(metapoll, MGW_ADDR)

switch_a = SwitchA(Weak(metapoll), A_ADDR, MGC1_ADDR, MGW_ADDR, range(30000, 30020, 2))
switch_b = SwitchB(Weak(metapoll), B_ADDR, MGC2_ADDR, MGW_ADDR, range(40000, 40020, 2))

#switch_a.transport.set_peer(switch_b.transport)
#switch_b.transport.set_peer(switch_a.transport)

while True:
    try:
        metapoll.do_poll()
    except KeyboardInterrupt:
        raise  #break
