#! /usr/bin/python3

from datetime import timedelta
import logging
import logging.config
from copy import deepcopy

from async import Metapoll, WeakMethod, Weak
from format import Addr, Uri, Nameaddr, Status, SipError, Hop
from transport import UdpTransport
from transactions import TransactionManager
#from dialog import Dialog, DialogManager
from leg import PlannedLeg
from call import Call, SimpleRouting, PlannedRouting
from sdp import Sdp
from authority import Authority
from registrar import RecordManager
from account import Account
from util import resolve, setup_exchandler, setup_logging, build_oid
from mgw import MediaGateway
from mgc import Controller  #, PlayerMediaLeg, EchoMediaLeg
from switch import Switch

HOST = "otthon"
A_ADDR = Addr(HOST, 5060)
B_ADDR = Addr(HOST, 5062)

A_DOMAIN = "a.switch"
B_DOMAIN = "b.switch"

CALLER_NAMEADDR = Nameaddr(Uri(Addr(B_DOMAIN, None), "caller"), "Caller")

CALLEE_NAMEADDR = Nameaddr(Uri(Addr(B_DOMAIN, None), "callee"), "Callee")

A_CRED = ("A_AUTHNAME", "A_HA1")
B_CRED = ("B_AUTHNAME", "B_HA1")

SNOM_NUMBER = "phone"
SNOM_CRED = ("phone", "38450ead4036feb352c45462d8008511")  # md5(phone:a.switch:secret)

CALLEE_NUMBER = "555"

CALLER_SDP = Sdp.parse("""
v=0
o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5
s=SDP Seminar
i=A Seminar on the session description protocol
u=http://www.example.com/seminars/sdp.pdf
e=j.doe@example.com (Jane Doe)
c=IN IP4 224.2.17.12
t=2873397496 2873404696
a=recvonly
m=audio 49170 RTP/AVP 0
m=video 51372 RTP/AVP 99
a=rtpmap:99 h263-1998/90000
""")

MGW_HOST = "localhost"
MGW_ADDR = Addr(MGW_HOST, 20000)

MEDIA_HOST = "otthon"


class UnreachableLeg(PlannedLeg):
    def plan(self):
        self.logger.debug("Unreachable leg created.")
        
        yield from self.wait_action("dial")
        self.logger.debug("Got dial, but not answering anything.")
        self.anchor()

        yield from self.wait_action("hangup")
        self.logger.debug("And now the caller hung up.")


class RejectingLeg(PlannedLeg):
    def plan(self):
        self.logger.debug("Rejecting leg created.")
        
        yield from self.wait_action("dial")
        self.logger.debug("Got dial, but not now rejecting it.")
        self.anchor()

        self.report(dict(type="reject", status=Status(603)))
        self.logger.debug("And now done.")


class RingingLeg(PlannedLeg):
    def plan(self):
        self.logger.debug("Ringing leg created.")
        
        yield from self.wait_action("dial")
        self.logger.debug("Got dial, now ringing forever.")
        self.anchor()

        self.report(dict(type="ring"))

        yield from self.wait_action("hangup")
        self.logger.debug("And now the caller hung up.")


class CalleeLeg(PlannedLeg):
    def plan(self):
        self.logger.debug("Callee created.")
        
        action = yield from self.wait_action("dial")
        self.offer = action.get("session")
        self.logger.debug("Got offer:\n%s" % repr(self.offer))
        self.anchor()
        
        yield from self.sleep(1)
        self.report(dict(type="ring"))
        
        yield from self.sleep(1)
        answer = self.make_answer(self.offer)
        
        media_leg = self.make_media_leg(0, "player")
        media_leg.play("playback.wav", ("PCMA", 8000, 1, None), volume=0.2, fade=3)
        # No refresh_media here, because we are the sender leg of the answer
        self.report(dict(type="accept", session=answer))

        while True:
            action = yield from self.wait_action()
            
            if action["type"] == "session":
                answer = self.make_answer(action["session"])
                self.report(dict(type="session", session=answer))
            elif action["type"] == "tone":
                self.logger.debug("Okay, go a tone %s, fading out..." % action["name"])
                break
                
        media_leg.play(volume=0, fade=3)
        yield from self.sleep(3)
        self.report(dict(type="hangup"))

        self.logger.debug("Callee done.")
        

    def make_answer(self, offer):
        answer = deepcopy(offer)
        answer["is_answer"] = True
        
        for c in answer["channels"]:
            c["send"], c["recv"] = c["recv"], c["send"]
            
        return answer


class CallerLeg(PlannedLeg):
    # TODO: call the phone without SDP!
    def plan(self):
        self.logger.debug("Caller created")
        
        yield from self.sleep(0)
        
        uri = Uri(Addr(A_DOMAIN, None), SNOM_NUMBER)
        self.ctx["from"] = CALLER_NAMEADDR
        self.ctx["to"] = Nameaddr(uri, "Snom")
        self.ctx["uri"] = uri
        
        offer = None  # FIXME: make one from CALLER_SDP!
        self.report(dict(type="dial", ctx=self.ctx, session=offer))

        action = yield from self.wait_action()
        
        if action["type"] == "reject":
            self.logger.error("Oops, we got rejected!")
            return
        elif action["type"] != "accept":
            self.logger.error("Oops, WTF: %s!" % action["type"])
            return
            
        offer = action.get("session")
        self.logger.debug("Accepted with SDP:\n%s" % repr(offer))

        answer = self.make_answer(offer)
        self.report(dict(type="session", session=answer))

        action = yield from self.expect("action")
        assert action["type"] == "hangup"
        
        self.logger.debug("Caller done.")
        #yield from self.sleep(3)
        #self.leg.do(dict(type="hangup"))


    def make_answer(self, offer):
        answer = deepcopy(offer)
        answer["is_answer"] = True
        
        for c in answer["channels"]:
            c["send"], c["recv"] = c["recv"], c["send"]
            
        return answer


class TestRecordManager(RecordManager):
    pass
        

class TestAuthority(Authority):
    pass


class TestController(Controller):
    def __init__(self, metapoll, ports):
        super().__init__(metapoll)
        
        #self.mgw_addr = resolve(mgw_addr)
        
        # Must use IP4 addresses or FQDN in SDP, so let's go with IP4
        # Media host may be different from the signaling host
        self.media_addresses = set(resolve(Addr(MEDIA_HOST, port)) for port in ports)
        
    
    def allocate_media_address(self, sid):
        return self.media_addresses.pop()
    
    
    def deallocate_media_address(self, sid, addr):
        self.media_addresses.add(addr)
        
        
class TestRouting(SimpleRouting):
    def route(self, action):
        ctx = action["ctx"]
        to_uri = ctx["to"].uri
        self.logger.debug("Checking registered SIP contact: %s" % (to_uri,))
        contacts = self.call.switch.record_manager.lookup_contacts(to_uri)
            
        if len(contacts) == 1:
            uri, hop = contacts[0]
            ctx["uri"] = uri  # Only update the RURI for forwarding
            ctx["hop"] = hop
        else:
            self.logger.debug("Has %d registered SIP contacts: %s" % (len(contacts), to_uri,))
            raise SipError(Status(404))


class TestSwitch(Switch):
    def __init__(self, metapoll, local_addr, mgw_addr, media_ports, routing_class):
        class TestCall(Call):
            def make_routing(self):
                return routing_class(Weak(self))
                
        self.call_class = TestCall
        
        transport = UdpTransport(metapoll, local_addr, WeakMethod(self.reception))
        transaction_manager = TransactionManager(local_addr, WeakMethod(transport.send))
        record_manager = TestRecordManager(WeakMethod(transaction_manager.send_message))
        authority = TestAuthority()
        #self.registration_manager = RegistrationManager(
        #    WeakMethod(self.transaction_manager.send_message),
        #    WeakMethod(self.transport.get_hop),
        #    WeakMethod(self.authing)
        #)
        #self.dialog_manager = DialogManager(
        #    local_addr,
        #    WeakMethod(self.transaction_manager.send_message),
        #    WeakMethod(self.transport.get_hop),
        #    WeakMethod(self.authing)
        #)
        mgc = TestController(metapoll, media_ports)
        mgc.add_mgw_addr(mgw_addr)
        #self.account_manager = AccountManager()

        Switch.__init__(
            self, local_addr, metapoll,
            transport=transport, transaction_manager=transaction_manager,
            record_manager=record_manager, authority=authority, registration_manager=None,
            dialog_manager=None, mgc=mgc, account_manager=None
        )

        metapoll.register_timeout(timedelta(seconds=0.2), WeakMethod(self.transaction_manager.maintenance), repeat=True)


    def make_leg(self, call, uri):
        if uri.scheme == "builtin":
            subtype = uri.addr.host
            
            if subtype == "callee":
                return CalleeLeg(self.metapoll)
            elif subtype == "unreachable":
                return UnreachableLeg(self.metapoll)
            elif subtype == "ringing":
                return RingingLeg(self.metapoll)
            else:
                raise Exception("Unknown builtin URI '%s'!" % uri.addr.host)
        else:
            return Switch.make_leg(self, call, uri)


    def make_call(self):
        return self.call_class(Weak(self))
        

class SwitchA(TestSwitch):
    def __init__(self, metapoll, *args):
        super().__init__(metapoll, *args, routing_class=TestRouting)
        
        # This can register to accept calls
        callee_uri = Uri(Addr(A_DOMAIN, None), CALLEE_NUMBER)
        self.account_manager.add_account(callee_uri, "Callee", Account.AUTH_IF_UNREGISTERED, B_CRED[0], B_CRED[1])
        
        # The Snom, too
        snom_uri = Uri(Addr(A_DOMAIN, None), SNOM_NUMBER)
        self.account_manager.add_account(snom_uri, "Snom", Account.AUTH_IF_UNREGISTERED, SNOM_CRED[0], SNOM_CRED[1])
        
        # This is to accept calls from it TODO: compute hop nicely!
        b_uri = Uri(Addr(B_DOMAIN, None), None)
        hop = Hop(local_addr=resolve(A_ADDR), remote_addr=resolve(B_ADDR), interface='eth0')
        self.account_manager.add_account(b_uri, "B", Account.AUTH_BY_HOP, None, None, hops=[ hop ])
        
        self.account_manager.set_our_credentials(*A_CRED)
        
        #metapoll.register_timeout(timedelta(seconds=2), WeakMethod(self.test_dialing))
        
        
    def test_dialing(self):
        self.logger.debug("Dialing begins.")

        #incoming_leg = CallerLeg()
        #self.start_call(incoming_leg)
        
        #incoming_leg.dial()


class SwitchB(TestSwitch):
    class RoutingClass(PlannedRouting):
        def plan(self, action):
            self.logger.debug("Routing plan started.")
            yield from self.sleep(0)  # yield necessary in a generator
            ctx = action["ctx"]
            uri = ctx["uri"]
            
            if uri.user == CALLEE_NUMBER:
                self.dial(dict(action, ctx=dict(action["ctx"], uri=Uri.parse("record:444@b.switch"))))
            elif uri.user == "444":
                self.dial(dict(action, ctx=dict(action["ctx"], uri=Uri.parse("builtin:unreachable"))))
                self.dial(dict(action, ctx=dict(action["ctx"], uri=Uri.parse("builtin:ringing"))))
                self.dial(dict(action, ctx=dict(action["ctx"], uri=Uri.parse("builtin:callee"))))
            elif uri.user == SNOM_NUMBER:
                self.dial(dict(action, ctx=dict(action["ctx"], uri=Uri(A_ADDR, SNOM_NUMBER))))
                
            #li, action = yield from self.wait_action()
            #self.forward(li, action)
            
            
    class XRoutingClass(TestRouting):
        def route(self, action):
            ctx = action["ctx"]
            uri = ctx["uri"]
            
            # For the phone call only
            if uri.user == CALLEE_NUMBER:
                self.logger.debug("Routing to CalleeLeg for %s" % CALLEE_NUMBER)
                ctx["uri"] = Uri.parse("builtin:callee")
                #return CalleeLeg(self.call, self.switch.metapoll)
                #self.logger.debug("Returning UnreachableLeg for %s" % CALLEE_NUMBER)
                #return UnreachableLeg(self.call, self.switch.metapoll)
                #self.logger.debug("Returning RejectingLeg for %s" % CALLEE_NUMBER)
                #return RejectingLeg(self.call, self.switch.metapoll)
            else:
                TestRouting.route(self, action)


    def __init__(self, metapoll, *args):
        super().__init__(metapoll, *args, routing_class=self.RoutingClass)
        
        phone_uri = Uri(Addr(A_DOMAIN, None), SNOM_NUMBER)
        
        self.account_manager.add_account(phone_uri, "Phone", Account.AUTH_IF_UNREGISTERED, A_CRED[0], A_CRED[1])
        
        self.account_manager.set_our_credentials(*B_CRED)

        #metapoll.register_timeout(timedelta(seconds=1), WeakMethod(self.test_registering))
        metapoll.register_timeout(timedelta(seconds=10), WeakMethod(self.test_dialing))


    def test_registering(self):
        self.logger.debug("Registering to Switch A.")

        self.registration_manager.start_registration(
            registrar_uri=Uri(A_ADDR),
            record_uri=Uri(Addr(A_DOMAIN, None), CALLEE_NUMBER),
            contact_uri=Uri(B_ADDR, CALLEE_NUMBER)
        )
        
        
    def test_dialing(self):
        self.logger.debug("Dialing begins.")

        incoming_leg = CallerLeg(self.metapoll)
        self.start_call(incoming_leg)


def main():
    # By using only local variables, they'll be released when exiting this function,
    # so various __del__ methods will run before interpreter shutdown, when even
    # logging is disfunctional.
    
    setup_exchandler()
    setup_logging()
    
    logging.debug("Hello!")

    metapoll = Metapoll()

    mgw = MediaGateway(metapoll, MGW_ADDR)
    mgw.set_oid("mgw")

    switch_a = SwitchA(Weak(metapoll), A_ADDR, MGW_ADDR, range(30000, 30020, 2))
    switch_a.set_oid(build_oid(None, "switch", "a"))
    
    switch_b = SwitchB(Weak(metapoll), B_ADDR, MGW_ADDR, range(40000, 40020, 2))
    switch_b.set_oid(build_oid(None, "switch", "b"))

    #switch_a.transport.set_peer(switch_b.transport)
    #switch_b.transport.set_peer(switch_a.transport)

    while True:
        try:
            metapoll.do_poll()
        except KeyboardInterrupt:
            #raise
            break

    del switch_b
    del switch_a
    del mgw
    del metapoll
    
    logging.debug("Bye!")


main()
