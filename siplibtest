#! /usr/bin/python3

from datetime import timedelta
import logging
import logging.config
from async import Metapoll, WeakMethod, Weak

from format import Addr, Uri, Nameaddr, Status
from transport import UdpTransport
from transactions import TransactionManager
#from dialog import Dialog, DialogManager
from leg import PlannedLeg
from call import Call, SimpleRouting, PlannedRouting
from sdp import Sdp
from authority import Authority
from registrar import RecordManager
from account import Account
from util import resolve, setup_exchandler, setup_logging, build_oid
from mgw import MediaGateway
from mgc import Controller, PlayerMediaLeg, EchoMediaLeg
from switch import Switch

HOST = "otthon"
A_ADDR = Addr(HOST, 5060)
B_ADDR = Addr(HOST, 5062)

A_DOMAIN = "a.switch"
B_DOMAIN = "b.switch"

#caller_uri = Uri(, "caller")
#caller_name = "Caller"
CALLER_NAMEADDR = Nameaddr(Uri(Addr(A_DOMAIN, None), "caller"), "Caller")

#callee_uri = Uri(b_addr, "callee")
#callee_name = "Callee"
#callee_nameaddr = Nameaddr(callee_uri, callee_name)
CALLEE_NAMEADDR = Nameaddr(Uri(Addr(B_DOMAIN, None), "callee"), "Callee")

#wrong_uri = Uri(local_addr, "wrong")

#CALLER_CRED = ("CALLER_AUTHNAME", "CALLER_HA1")
#CALLEE_CRED = ("CALLEE_AUTHNAME", "CALLEE_HA1")
A_CRED = ("A_AUTHNAME", "A_HA1")
B_CRED = ("B_AUTHNAME", "B_HA1")

PHONE_CALLERID = "phone"
PHONE_NUMBER = "555"
#phone_cred = ("phone", "29947c88227ea55104f09dbdd5e6c48e")  # md5(phone:A-NET:secret)
PHONE_CRED = ("phone", "38450ead4036feb352c45462d8008511")  # md5(phone:a.switch:secret)

CALLER_SDP = Sdp.parse("""
v=0
o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5
s=SDP Seminar
i=A Seminar on the session description protocol
u=http://www.example.com/seminars/sdp.pdf
e=j.doe@example.com (Jane Doe)
c=IN IP4 224.2.17.12
t=2873397496 2873404696
a=recvonly
m=audio 49170 RTP/AVP 0
m=video 51372 RTP/AVP 99
a=rtpmap:99 h263-1998/90000
""")

MGW_HOST = "localhost"
#MGC1_HOST = "localhost"
#MGC2_HOST = "localhost"
MGW_ADDR = Addr(MGW_HOST, 20000)
#MGC1_ADDR = Addr(MGC1_HOST, 20001)
#MGC2_ADDR = Addr(MGC2_HOST, 20002)

MEDIA_HOST = "otthon"


class UnreachableLeg(PlannedLeg):
    def plan(self):
        self.logger.debug("Unreachable leg created.")
        
        yield from self.wait_action("dial")
        self.logger.debug("Got dial, but not answering anything.")

        yield from self.wait_action("cancel")
        self.logger.debug("And now the caller hung up.")


class RejectingLeg(PlannedLeg):
    def plan(self):
        self.logger.debug("Rejecting leg created.")
        
        yield from self.wait_action("dial")
        self.logger.debug("Got dial, but not now rejecting it.")

        self.report(dict(type="reject", status=Status(603)))

        self.logger.debug("And now done.")


class CalleeLeg(PlannedLeg):
    def plan(self):
        self.logger.debug("Callee created.")
        
        action = yield from self.wait_action("dial")
        self.offer = action.get("offer")
        self.logger.debug("Got offer:\n%s" % repr(self.offer))
        
        yield from self.sleep(1)
        self.report(dict(type="ring"))
        
        yield from self.sleep(1)
        answer = self.make_answer(self.offer)
        sid = self.call.select_gateway_sid(0)
        #media_leg = PlayerMediaLeg(self.call.switch.mgc, sid)
        media_leg = EchoMediaLeg(self.call.switch.mgc, sid)
        self.append_media_leg(media_leg)
        self.report(dict(type="accept", answer=answer))
        # TODO: It shouldn't be legal to answer without channels existing already!
        
        #self.media_legs[0].play("playback.wav", ("PCMA", 8000), volume=0.2, fade=3)
        #self.refresh_media()
        
        yield from self.sleep(3)
        #self.media_legs[0].play(volume=0, fade=3)
        #self.refresh_media()
        
        yield from self.sleep(3)
        self.report(dict(type="hangup"))

        self.logger.debug("Callee done.")
        

    def make_answer(self, offer):
        return offer


class CallerLeg(PlannedLeg):
    def plan(self):
        self.logger.debug("Caller created")
        
        yield from self.sleep(0)
        self.ctx["from"] = CALLER_NAMEADDR
        self.ctx["to"] = Nameaddr(CALLEE_NAMEADDR.uri)
        self.report(dict(type="dial", ctx=self.ctx, offer=CALLER_SDP))

        action = yield from self.wait_action("accept")
        self.logger.debug("Accepted with SDP:\n%s" % repr(action.get("answer")))

        action = yield from self.expect("action")
        assert action["type"] == "hangup"
        
        self.logger.debug("Caller done.")
        #yield from self.sleep(3)
        #self.leg.do(dict(type="hangup"))


class TestRecordManager(RecordManager):
    pass
        

class TestAuthority(Authority):
    pass


class TestController(Controller):
    def __init__(self, metapoll, ports):
        super().__init__(metapoll)
        
        #self.mgw_addr = resolve(mgw_addr)
        
        # Must use IP4 addresses or FQDN in SDP, so let's go with IP4
        # Media host may be different from the signaling host
        self.media_addresses = set(resolve(Addr(MEDIA_HOST, port)) for port in ports)
        
    
    def allocate_media_address(self, sid):
        return self.media_addresses.pop()
    
    
    def deallocate_media_address(self, sid, addr):
        self.media_addresses.add(addr)
        
        
class TestRouting(SimpleRouting):
    def route_ctx(self, ctx):
        to_uri = ctx["to"].uri
        self.logger.debug("Checking registered SIP contact: %s" % (to_uri,))
        contacts = self.call.switch.record_manager.lookup_contacts(to_uri)
            
        if len(contacts) == 1:
            uri, hop = contacts[0]
            ctx["uri"] = uri  # Only update the RURI for forwarding
            ctx["hop"] = hop
        else:
            self.logger.debug("Not one registered SIP contact: %s" % (to_uri,))
            raise Exception("Routing failed!")


class TestSwitch(Switch):
    def __init__(self, metapoll, local_addr, mgw_addr, media_ports, routing_class):
        class TestCall(Call):
            def make_routing(self):
                return routing_class(Weak(self))
                
        self.call_class = TestCall
        
        transport = UdpTransport(metapoll, local_addr, WeakMethod(self.reception))
        transaction_manager = TransactionManager(local_addr, WeakMethod(transport.send))
        record_manager = TestRecordManager(WeakMethod(transaction_manager.send_message))
        authority = TestAuthority()
        #self.registration_manager = RegistrationManager(
        #    WeakMethod(self.transaction_manager.send_message),
        #    WeakMethod(self.transport.get_hop),
        #    WeakMethod(self.authing)
        #)
        #self.dialog_manager = DialogManager(
        #    local_addr,
        #    WeakMethod(self.transaction_manager.send_message),
        #    WeakMethod(self.transport.get_hop),
        #    WeakMethod(self.authing)
        #)
        mgc = TestController(metapoll, media_ports)
        mgc.add_mgw_addr(mgw_addr)
        #self.account_manager = AccountManager()

        Switch.__init__(
            self, local_addr, metapoll,
            transport=transport, transaction_manager=transaction_manager,
            record_manager=record_manager, authority=authority, registration_manager=None,
            dialog_manager=None, mgc=mgc, account_manager=None
        )

        metapoll.register_timeout(timedelta(seconds=0.2), WeakMethod(self.transaction_manager.maintenance), repeat=True)


    def make_outgoing_leg(self, uri):
        if uri.scheme == "builtin":
            subtype = uri.addr.host
            
            if subtype == "callee":
                return CalleeLeg(self.metapoll)
            elif subtype == "unreachable":
                return UnreachableLeg(self.metapoll)
            else:
                raise Exception("Unknown builtin URI '%s'!" % uri.addr.host)
        else:
            return Switch.make_outgoing_leg(self, uri)


    def make_call(self):
        return self.call_class(Weak(self))
        

class SwitchA(TestSwitch):
    def __init__(self, metapoll, *args):
        super().__init__(metapoll, *args, routing_class=TestRouting)
        
        player_uri = Uri(Addr(A_DOMAIN, None), PHONE_NUMBER)
        phone_uri = Uri(Addr(A_DOMAIN, None), PHONE_CALLERID)
        
        self.account_manager.add_account(player_uri, "Playa", Account.AUTH_IF_UNREGISTERED, B_CRED[0], B_CRED[1])
        self.account_manager.add_account(phone_uri, "Phone", Account.AUTH_IF_UNREGISTERED, PHONE_CRED[0], PHONE_CRED[1])

        self.account_manager.set_our_credentials(*A_CRED)
        
        #metapoll.register_timeout(timedelta(seconds=2), WeakMethod(self.test_dialing))
        
        
    def test_dialing(self):
        self.logger.debug("Dialing begins.")

        #incoming_leg = CallerLeg()
        #self.start_call(incoming_leg)
        
        #incoming_leg.dial()
    

class SwitchB(TestSwitch):
    class RoutingClass(PlannedRouting):
        def plan(self, action):
            self.logger.debug("Routing plan started.")
            self.dial(dict(action, ctx=dict(action["ctx"], uri=Uri.parse("builtin:unreachable"))))
            self.dial(dict(action, ctx=dict(action["ctx"], uri=Uri.parse("builtin:callee"))))
            li, action = yield from self.wait_action()
            self.forward(li, action)
            
            
    class XRoutingClass(TestRouting):
        def route_ctx(self, ctx):
            # For the phone call only
            if ctx["to"].uri.user == PHONE_NUMBER:
                self.logger.debug("Routing to CalleeLeg for %s" % PHONE_NUMBER)
                ctx["uri"] = Uri.parse("builtin:callee")
                #return CalleeLeg(self.call, self.switch.metapoll)
                #self.logger.debug("Returning UnreachableLeg for %s" % PHONE_NUMBER)
                #return UnreachableLeg(self.call, self.switch.metapoll)
                #self.logger.debug("Returning RejectingLeg for %s" % PHONE_NUMBER)
                #return RejectingLeg(self.call, self.switch.metapoll)
            else:
                TestRouting.route_call(self, ctx)


    def __init__(self, metapoll, *args):
        super().__init__(metapoll, *args, routing_class=self.RoutingClass)
        
        phone_uri = Uri(Addr(A_DOMAIN, None), PHONE_CALLERID)
        
        self.account_manager.add_account(phone_uri, "Phone", Account.AUTH_IF_UNREGISTERED, A_CRED[0], A_CRED[1])
        
        self.account_manager.set_our_credentials(*B_CRED)

        metapoll.register_timeout(timedelta(seconds=1), WeakMethod(self.test_registering))


    def test_registering(self):
        self.logger.debug("Registering begins.")

        self.registration_manager.start_registration(
        #    a_registrar, callee_uri, callee_uri
            registrar_uri=Uri(A_ADDR),
            record_uri=Uri(Addr(A_DOMAIN, None), PHONE_NUMBER),
            contact_uri=Uri(B_ADDR, PHONE_NUMBER)
        )


def main():
    # By using only local variables, they'll be released when exiting this function,
    # so various __del__ methods will run before interpreter shutdown, when even
    # logging is disfunctional.
    
    setup_exchandler()
    setup_logging()
    
    logging.debug("Hello!")

    metapoll = Metapoll()

    mgw = MediaGateway(metapoll, MGW_ADDR)
    mgw.set_oid("mgw")

    switch_a = SwitchA(Weak(metapoll), A_ADDR, MGW_ADDR, range(30000, 30020, 2))
    switch_a.set_oid(build_oid(None, "switch", "a"))
    
    switch_b = SwitchB(Weak(metapoll), B_ADDR, MGW_ADDR, range(40000, 40020, 2))
    switch_b.set_oid(build_oid(None, "switch", "b"))

    #switch_a.transport.set_peer(switch_b.transport)
    #switch_b.transport.set_peer(switch_a.transport)

    while True:
        try:
            metapoll.do_poll()
        except KeyboardInterrupt:
            #raise
            break

    del switch_b
    del switch_a
    del mgw
    del metapoll
    
    logging.debug("Bye!")


main()
