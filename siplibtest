#! /usr/bin/python3

import os
import logging
import logging.config
import sys
from weakref import proxy
#from pprint import pformat

from format import Addr, Uri, Nameaddr, Status, Hop, AbsoluteUri, CallInfo
from party import PlannedEndpoint, PlannedRouting, Bridge, Routing
from sdp import Session
from registrar import LocalRecord
from subscript import SubscriptionManager, MessageSummaryEventSource, DialogEventSource
from log import setup_logging, log_exception, Oid
from mgw import MediaGateway
from mgc import Controller  #, PlayerMediaLeg  #, EchoMediaLeg
from switch import Switch
import zap
import resolver

TEST_DIALIN = 1
TEST_DIALOUT = 2
TEST = TEST_DIALIN

NUMBER_A_PREFIX = "2"
NUMBER_A_SNOM_1 = "201"
NUMBER_A_SNOM_2 = "202"
NUMBER_A_REMOTE_CALLEE = "240"
NUMBER_A_LOCAL_CALLEE = "250"
NUMBER_A_LOCAL_UNREACHABLE = "251"
NUMBER_A_LOCAL_REJECTING = "252"
NUMBER_A_LOCAL_RINGING = "253"
NUMBER_A_SERVICE_VOICEMAIL = "260"

NUMBER_B_PREFIX = "3"
NUMBER_B_LOCAL_CALLEE = "350"
NUMBER_B_LOCAL_RECORD = "360"
NUMBER_B_LOCAL_FORK = "361"

NUMBER_DDI_CALLER = "400"

HOST = "otthon"
MEDIA_HOST = "otthon"
MGW_HOST = "localhost"
MGW_ADDR = Addr(MGW_HOST, 20000)

A_ADDR = Addr(HOST, 5060)
A_DOMAIN = "a.switch"
A_AUTHNAME = "A_AUTHNAME"
A_HA1 = "A_HA1"

B_ADDR = Addr(HOST, 5062)
B_DOMAIN = "b.switch"
B_AUTHNAME = "B_AUTHNAME"
B_HA1 = "B_HA1"

DDI_DOMAIN = "d.switch"

SNOM_AUTHNAME = "phone"
SNOM_HA1 = "38450ead4036feb352c45462d8008511"  # md5(phone:a.switch:secret)
SNOM_WEB = Addr("192.168.1.7", 80)

CALLER_NAMEADDR = Nameaddr(Uri(Addr(B_DOMAIN, None), "caller"), "Caller")
CALLEE_NAMEADDR = Nameaddr(Uri(Addr(B_DOMAIN, None), "callee"), "Callee")

TEST_ENDPOINT_SESSION = dict(
    attributes=[],
    bandwidth=None,
    channels=[ {
        'type': 'audio',
        'proto': 'RTP/AVP',
        'send': True,
        'recv': True,
        'attributes': [('ptime', '20')],
        'formats': [ {
            'clock': 8000, 'encoding': 'PCMA', 'encp': 1, 'fmtp': None
        }, {
            'clock': 8000, 'encoding': 'telephone-event', 'encp': 1, 'fmtp': '0-15'
        } ]
    } ]
)



class TestEndpoint(PlannedEndpoint):
    def identify(self, params):
        return None
        

    def wait_this_action(self, action_type):
        action = yield from self.wait_action()
        assert action and action["type"] == action_type
        return action
        
        
    def add_media_leg(self, channel):
        ctype = channel["type"]
        mgw_affinity = channel.get("mgw_affinity")
        mgw_sid = self.ground.select_gateway_sid(ctype, mgw_affinity)

        channel["mgw_affinity"] = mgw_sid
        media_leg = self.make_media_leg("player")
        media_leg.set_mgw(mgw_sid)
        self.leg.add_media_leg(media_leg)
    

    def update_session(self, session):
        if session.is_query():
            self.logger.info("TestEndpoint received a session query.")
            
            return Session.make_offer(**TEST_ENDPOINT_SESSION)
        elif session.is_offer():
            self.logger.info("TestEndpoint received a session offer.")
            
            answer = session.flipped()
        
            for c in answer["channels"]:
                c["formats"] = [ f for f in c["formats"] if f["encoding"] in ("PCMA", "telephone-event") ]
                c["send"], c["recv"] = c["recv"], c["send"]

            if not self.leg.media_legs:
                self.add_media_leg(answer["channels"][0])
        
            return answer
        elif session.is_accept():
            self.logger.info("TestEndpoint received a session accept.")
            
            if not self.leg.media_legs:
                self.add_media_leg(session["channels"][0])
                
            return None
        elif session.is_reject():
            self.logger.info("TestEndpoint received a session reject.")
            
            raise Exception("Eiii...")
        
        
    def idle(self):
        self.leg.get_media_leg(0).play("playback.wav", ("PCMA", 8000, 1, None), volume=0.1, fade=3)

        while True:
            action = yield from self.wait_action()
            type = action["type"]
            self.logger.info("Got a %s while idle." % type)
            
            if type == "session":
                session = self.update_session(action["session"])
                if session:
                    self.forward(dict(type="session", session=session))
            elif type == "tone":
                self.logger.info("Okay, got a tone %s, fading out..." % action["name"])
                break
            elif type == "hangup":
                self.logger.info("Okay, got a hangup, fading out...")
                break
            elif type == "transfer":
                self.logger.info("Got a transfer, being transferred...")
                self.process_transfer(action)
            else:
                self.logger.critical("Don't know what to do with %s, continuing..." % type)
        
        if self.leg.media_legs:
            self.leg.media_legs[0].play(volume=0, fade=3)
            yield from self.sleep(3)
            
        if type != "hangup":
            self.forward(dict(type="hangup"))


class UnreachableEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Unreachable endpoint created.")
        
        yield from self.wait_this_action("dial")
        self.logger.debug("Got dial, but not answering anything.")

        yield from self.wait_this_action("hangup")
        self.logger.debug("And now the caller hung up.")


class RejectingEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Rejecting endpoint created.")
        
        yield from self.wait_this_action("dial")
        self.logger.debug("Got dial, but not now rejecting it.")

        self.forward(dict(type="reject", status=Status(603)))
        self.logger.debug("And now done.")


class RingingEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Ringing endpoint created.")
        
        yield from self.wait_this_action("dial")
        self.logger.debug("Got dial, now ringing forever.")

        self.forward(dict(type="ring"))

        yield from self.wait_this_action("hangup")
        self.logger.debug("And now the caller hung up.")


class CalleeEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Callee created.")
        
        action = yield from self.wait_this_action("dial")
        offer = action.get("session")
        self.logger.debug("Got offer:\n%s" % repr(offer))
        
        yield from self.sleep(1)
        answer = self.update_session(offer)
        self.forward(dict(type="ring", session=answer))
        
        # Force an UPDATE
        yield from self.sleep(1)
        offer = answer.flipped()
        self.forward(dict(type="session", session=offer))

        action = yield from self.wait_this_action("session")
        answer = action.get("session")
        self.logger.debug("Got answer:\n%s" % repr(answer))

        yield from self.sleep(1)
        self.forward(dict(type="accept"))

        yield from self.idle()
        
        self.logger.debug("Callee done.")


class CallerEndpoint(TestEndpoint):
    def plan(self):
        self.logger.debug("Caller created")
        
        address = yield from resolver.wait_resolve("index.hu")
        self.logger.debug("Resolved index.hu asynchronously to: %s" % address)
        
        yield from self.wait_input("Press any key to dial out!")
        
        src = {
            'type': "sip",  # FIXME: we lie here for mkctx
            'from': Nameaddr(Uri(Addr(B_DOMAIN), NUMBER_DDI_CALLER), "Caller"),
            'to': Nameaddr(Uri(Addr(B_DOMAIN), NUMBER_A_SNOM_1))
        }
        
        offer = None
        action = dict(
            type="dial",
            call_info=self.get_call_info(),
            src=src,
            ctx={},
            session=offer
        )
        self.forward(action)

        while True:
            action = yield from self.wait_action()
        
            if action["type"] == "reject":
                self.logger.error("Oops, we got rejected!")
                return
            elif action["type"] == "accept":
                self.logger.info("Yay, accepted!")
                session = action.get("session")
                
                if session and session.is_offer():
                    answer = self.update_session(session)
                    self.forward(dict(type="session", session=answer))
                    
                break
            elif action["type"] == "session":
                session = action.get("session")
                
                if session.is_offer():
                    # This is the offer from an RPR, we'll answer in a PRACK request
                    offer = session
                    answer = self.update_session(offer)
                    self.forward(dict(type="session", session=answer))
                    
                    # Then send another offer to force an UPDATE
                    offer = answer.flipped()
                    self.forward(dict(type="session", session=offer))
                else:
                    # This is the answer from the UPDATE response, no need to process it
                    pass
            else:
                self.logger.error("Hm, we got: %s!" % action["type"])
            
        #session = action.get("session")
        #if session and session.is_offer():
        #    answer = self.update_session(session)
        #    self.forward(dict(type="session", session=answer))

        # Be more flexible here!
        yield from self.idle()

        self.logger.debug("Caller done.")


class VoicemailEventSource(MessageSummaryEventSource):
    def identify(self, params):
        self.mailbox = params["mailbox"]

        self.state = 0
        zap.time_slot(30, True).plug(self.fake)
        
        return self.mailbox
        
        
    def fake(self):
        self.notify_all()
        self.state += 1

        
    def get_message_state(self):
        return dict(voice=self.state % 2, voice_old=self.state / 2 % 2)


class BusylampEventSource(DialogEventSource):
    def identify(self, params):
        self.set_entity(params["entity"])

        self.calls_by_number = {}
        self.state = 0

        return self.entity
        
        
    def update(self, call_number, is_outgoing, is_confirmed):
        if is_outgoing is None and is_confirmed is None:
            self.calls_by_number.pop(call_number)
        else:
            self.calls_by_number[call_number] = dict(is_outgoing=is_outgoing, is_confirmed=is_confirmed)
            
        self.logger.info("%s: %s" % (self.entity, self.calls_by_number))
        
        self.notify_all()
            
        
    def fake(self):
        self.notify_all()
        self.state += 1
        
        
    def get_dialog_state(self):
        return self.calls_by_number
            

class TestSubscriptionManager(SubscriptionManager):
    def identify_event_source(self, params):
        event = params["event"]
        from_uri = params["from"].uri
        to_uri = params["to"].uri
        
        if event == "message-summary" and to_uri.username == NUMBER_A_SERVICE_VOICEMAIL:
            return "voicemail", from_uri.username
            
        if event == "dialog":
            return "busylamp", to_uri.username
            
        return None
        
        
    def make_event_source(self, type):
        if type == "voicemail":
            return VoicemailEventSource()
        elif type == "busylamp":
            return BusylampEventSource()
        else:
            return None


class TestController(Controller):
    def start(self, addr_set):
        # Must use IP4 addresses or FQDN in SDP, so let's go with IP4
        # Media host may be different from the signaling host
        self.media_addresses = addr_set  #set(Addr(MEDIA_HOST, port).resolved() for port in ports)
        
    
    def allocate_media_address(self, mgw_sid):
        return self.media_addresses.pop()
    
    
    def deallocate_media_address(self, addr):
        self.media_addresses.add(addr)
        
        
class TestLine(Bridge):
    def identify(self, params):
        self.is_outgoing = None  # if the device dialed out
        self.is_confirmed = None
        
        self.addr = params["addr"]
        self.username = params["username"]
        
        return "%s@%s" % (self.username, self.addr)
        
        
    def update_busylamp_state(self):
        es = self.ground.switch.subscription_manager.get_event_source("busylamp", self.username)
        
        if es:
            es.update(self.call_info["number"], self.is_outgoing, self.is_confirmed)
        
        
    def process_dial(self, action):
        ctx = action["ctx"]
        
        src_username = ctx["src_username"]
        src_addr = ctx["src_addr"]
        src_name = ctx["src_name"]
        
        dst_username = ctx["dst_username"]
        dst_addr = ctx["dst_addr"]
        
        if self.username != dst_username or self.addr != dst_addr:
            self.is_outgoing = True
            self.is_confirmed = False
            self.update_busylamp_state()
            self.dial(action)
            return
            
        self.is_outgoing = False
        self.is_confirmed = False
        self.update_busylamp_state()
        
        record_uri = Uri(dst_addr, dst_username)
        self.logger.debug("Checking registered SIP contact: %s" % (record_uri,))
        contacts = self.ground.switch.record_manager.lookup_contacts(record_uri)
        
        if len(contacts) == 1:
            contact = contacts[0]
        
            dst = {
                'type': "sip",
                'uri': contact.uri,
                'hop': contact.hop,
                'from': Nameaddr(Uri(src_addr, src_username), src_name),
                'to': Nameaddr(Uri(dst_addr, dst_username)),
                'route': [],
                'x_alert_info': [ CallInfo(AbsoluteUri("http", "//www.notused.com"), dict(info="alert-autoanswer", delay="0")) ]
            }
        
            self.dial(action, **dst)
        else:
            self.logger.debug("Has %d registered SIP contacts: %s" % (len(contacts), record_uri))
            self.reject_incoming_leg(Status(404))
            
            
    def process_leg_transfer(self, li, action):
        if not self.is_outgoing and li > 0:
            self.forward(0, action)
        elif self.is_outgoing and li == 0:
            self.forward(max(self.legs.keys()), action)
        else:
            Bridge.process_leg_transfer(self, li, action)
            
            
    def do_slot(self, li, action):
        type = action["type"]
        
        if type == "accept":
            self.is_confirmed = True
            self.update_busylamp_state()
        elif type in ("reject", "hangup"):
            self.is_outgoing = None
            self.is_confirmed = None
            self.update_busylamp_state()
            
        return Bridge.do_slot(self, li, action)
    

class TestSwitch(Switch):
    def __init__(self):
        subman = TestSubscriptionManager(proxy(self))
        mgc = TestController()

        Switch.__init__(
            self,
            subscription_manager=subman,
            dialog_manager=None, mgc=mgc, account_manager=None
        )


    def start(self, realm, local_addr, mgw_addr, media_addrs):
        self.realm = realm
        
        local_addr.assert_resolved()
        mgw_addr.assert_resolved()

        self.mgc.start(media_addrs)
        self.mgc.add_mgw_addr(mgw_addr)
        
        hop = Hop("UDP", "eth0", local_addr, None)
        self.transport_manager.add_hop(hop)
        
        hop = Hop("TCP", "eth0", local_addr, None)
        self.transport_manager.add_hop(hop)


    def make_party(self, type):
        if type == "caller":
            return CallerEndpoint()
        elif type == "callee":
            return CalleeEndpoint()
        elif type == "unreachable":
            return UnreachableEndpoint()
        elif type == "ringing":
            return RingingEndpoint()
        elif type == "line":
            return TestLine()
        else:
            return Switch.make_party(self, type)


    def reregister_snom(self, addr, line):
        post_data = "REREGISTER%3A1=Re-Register"
        url = "http://%s/line_login.htm?l=%d" % (addr, line)
        os.system("wget -q --output-document=/dev/null --post-data='%s' '%s'" % (post_data, url))


    def add_record_account(self, uri, authname, ha1, policy, hops=[]):
        if not self.account_manager.get_local_account(authname):
            self.account_manager.add_local_account(authname, ha1, self.realm)
            
        record = self.registrar.add_local_record(uri, authname, policy)
        
        for hop in hops:
            record.add_static_contact(uri, hop)  # assume same contact uri as the aor


def mkctx(src):
    if src["type"] == "sip":
        return dict(
            src_addr=src["from"].uri.addr,
            src_username=src["from"].uri.username,
            src_name=src["from"].name,
            dst_addr=src["to"].uri.addr,
            dst_username=src["to"].uri.username,
            dst_name=src["to"].name
        )
    else:
        raise Exception("Unknown src type: %s!" % src["type"])
    

class SwitchA(TestSwitch):
    class ARouting(Routing):
        def process_dial(self, action):
            ctx = action["ctx"]
            
            if not ctx:
                ctx.update(mkctx(action["src"]))
                
                self.dial(action, "line", addr=ctx["src_addr"], username=ctx["src_username"])
                return

            number = ctx["dst_username"]
            
            if number >= "200" and number < "250":
                # Numbers for registering clients
                self.dial(action, "line", addr=ctx["dst_addr"], username=ctx["dst_username"])
                return
            elif number >= "250" and number < "260":
                # Numbers for local clients
                if number == NUMBER_A_LOCAL_CALLEE:
                    self.dial(action, "callee")
                    return
                elif number == NUMBER_A_LOCAL_UNREACHABLE:
                    self.dial(action, "unreachable")
                    return
                elif number == NUMBER_A_LOCAL_REJECTING:
                    self.dial(action, "rejecting")
                    return
                elif number == NUMBER_A_LOCAL_RINGING:
                    self.dial(action, "ringing")
                    return
            elif number >= "300" and number < "400":
                # Numbers for switch B
                dst = {
                    'type': "sip",
                    'uri': Uri(B_ADDR),
                    #'hop': contact.hop,
                    'from': Nameaddr(Uri(Addr(A_DOMAIN), ctx["src_username"]), ctx["src_name"]),
                    'to': Nameaddr(Uri(Addr(B_DOMAIN), number))  # divert to B
                    #'route': []
                }
                
                self.dial(action, **dst)
                return
                
            self.logger.error("Not found: %s" % number)
            

    def start(self, realm, local_addr, mgw_addr, media_addrs):
        TestSwitch.start(self, realm, local_addr, mgw_addr, media_addrs)
        
        # CALLEE lives on switch-b, but registers here to take calls from here
        remote_callee_aor = Uri(Addr(A_DOMAIN), NUMBER_A_REMOTE_CALLEE)
        self.add_record_account(remote_callee_aor, B_AUTHNAME, B_HA1, LocalRecord.AUTH_IF_UNREGISTERED)
        
        # SNOM lives on its own device, but also registers here
        snom_aor = Uri(Addr(A_DOMAIN), NUMBER_A_SNOM_1)
        self.add_record_account(snom_aor, SNOM_AUTHNAME, SNOM_HA1, LocalRecord.AUTH_IF_UNREGISTERED)
        
        # Allow calls from anyone on switch B as long as they use this hop
        b_aor = Uri(Addr(B_DOMAIN), None)
        hop1 = Hop('UDP', 'eth0', A_ADDR.resolved(), B_ADDR.resolved())
        hop2 = Hop('TCP', 'eth0', A_ADDR.resolved(), B_ADDR._replace(port=None).resolved())
        self.add_record_account(b_aor, B_AUTHNAME, B_HA1, LocalRecord.AUTH_BY_HOP, [ hop1, hop2 ])
        
        # Allow us to authenticate requests sent to B
        self.account_manager.add_remote_account(Uri(Addr(B_DOMAIN), None), A_AUTHNAME, A_HA1)

        # Add a voicemail box to monitor
        self.subscription_manager.add_event_source("voicemail", dict(mailbox="201"))
        
        # Add a line state
        self.subscription_manager.add_event_source("busylamp", dict(entity="201"))


    def make_party(self, type):
        if type == "routing":
            return self.ARouting()
        else:
            return TestSwitch.make_party(self, type)
        

class SwitchB(TestSwitch):
    class BRouting(PlannedRouting):
        def plan(self):
            self.logger.debug("Routing plan started.")
            li, action = yield from self.wait_leg_action()
            ctx = action["ctx"]
            
            if not ctx:
                ctx.update(mkctx(action["src"]))

                self.dial(action, "line", addr=ctx["src_addr"], username=ctx["src_username"])
                #self.dial(action, "record", id="prekord")
                return

            src_username = ctx["src_username"]
            src_addr = ctx["src_addr"]
            src_name = ctx["src_name"]
        
            dst_username = ctx["dst_username"]
            dst_addr = ctx["dst_addr"]
            
            if dst_addr == Addr(A_DOMAIN):
                if dst_username == NUMBER_A_REMOTE_CALLEE:
                    # This was forwarded here from A because we registered there,
                    # so the domain remained A_DOMAIN.
                    self.dial(action, "callee")
                    return
            elif dst_addr == Addr(B_DOMAIN):
                if dst_username == NUMBER_B_LOCAL_CALLEE:
                    self.dial(action, "callee")
                    return
                elif dst_username == NUMBER_B_LOCAL_RECORD:  # was: 555
                    ctx["dst_username"] = NUMBER_B_LOCAL_FORK
                    self.dial(action, "record", id="rekord")
                    return
                elif dst_username == NUMBER_B_LOCAL_FORK:  # was: 444
                    self.dial(action, "unreachable")
                    self.dial(action, "ringing")
                    self.dial(action, "callee")
                    return
                elif dst_username >= "200" and dst_username < "300":
                    dst = {
                        'type': "sip",
                        'uri': Uri(A_ADDR),
                        #'hop': contact.hop,
                        'from': Nameaddr(Uri(src_addr, src_username), src_name),
                        'to': Nameaddr(Uri(Addr(A_DOMAIN), dst_username)),  # divert to A
                        #'route': []
                    }
                
                    self.dial(action, **dst)
                    return
            
            self.logger.error("Not found: %s" % dst_username)
            
            
    def start(self, realm, local_addr, mgw_addr, media_addrs):
        TestSwitch.start(self, realm, local_addr, mgw_addr, media_addrs)
        
        #phone_uri = Uri(Addr(A_DOMAIN, None), SNOM_NUMBER)
        #self.add_record_account(phone_uri, A_AUTHNAME, A_HA1, LocalRecord.AUTH_IF_UNREGISTERED)
        
        #self.account_manager.add_account(phone_uri, "Phone", Account.AUTH_IF_UNREGISTERED, A_CRED[0], A_CRED[1])

        # Allow calls from anyone on switch A as long as they authenticate themselves as A
        a_aor = Uri(Addr(A_DOMAIN), None)
        self.add_record_account(a_aor, A_AUTHNAME, A_HA1, LocalRecord.AUTH_ALWAYS)
        
        # Allow us to authenticate ourselves at A
        self.account_manager.add_remote_account(Uri(Addr(A_DOMAIN), None), B_AUTHNAME, B_HA1)

        zap.time_slot(1).plug(self.reregister_snom, addr=SNOM_WEB, line=1)

        if TEST == TEST_DIALOUT:
            zap.time_slot(3).plug(self.test_dialing)
            
        if TEST == TEST_DIALIN:
            zap.time_slot(3).plug(self.test_registering)


    def make_party(self, type):
        if type == "routing":
            return self.BRouting()
        else:
            return TestSwitch.make_party(self, type)


    def test_registering(self):
        self.logger.debug("Registering to Switch A.")

        self.registrar.add_remote_record(
            Uri(Addr(A_DOMAIN), NUMBER_A_REMOTE_CALLEE),
            registrar_uri=Uri(A_ADDR)
        )
        
        
    def test_dialing(self):
        self.logger.debug("Dialing begins.")

        self.start_call("caller")


def main():
    # By using only local variables, they'll be released when exiting this function,
    # so various __del__ methods will run before interpreter shutdown, when even
    # logging is disfunctional.
    
    setup_logging()
    logging.debug("Hello!")

    mgw = MediaGateway(MGW_ADDR.resolved())
    mgw.set_oid(Oid("mgw"))
    mgw.set_name(Oid("the-mgw"))

    switch_a = SwitchA()
    switch_a.set_oid(Oid().add("switch", "a"))
    switch_a.set_name("switch-a")
    media_addrs = { Addr(MEDIA_HOST, port).resolved() for port in range(30000, 30020, 2) }
    switch_a.start(A_DOMAIN, A_ADDR.resolved(), MGW_ADDR.resolved(), media_addrs)
    
    switch_b = SwitchB()
    switch_b.set_oid(Oid().add("switch", "b"))
    switch_b.set_name("switch-b")
    media_addrs = { Addr(MEDIA_HOST, port).resolved() for port in range(40000, 40020, 2) }
    switch_b.start(B_DOMAIN, B_ADDR.resolved(), MGW_ADDR.resolved(), media_addrs)

    try:
        zap.loop()
    except Exception:
        logging.critical("Crashed!")
        log_exception(*sys.exc_info())
    else:
        logging.critical("Shutting down.")
    finally:
        # The exception object is already gone here
        
        del switch_b
        del switch_a
        del mgw
    
        logging.debug("Bye!")
        logging.shutdown()


main()
